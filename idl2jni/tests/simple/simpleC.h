// -*- C++ -*-
// $Id$

/**
 * Code generated by the The ACE ORB (TAO) IDL Compiler v2.2a_p9
 * TAO and the TAO IDL Compiler have been developed by:
 *       Center for Distributed Object Computing
 *       Washington University
 *       St. Louis, MO
 *       USA
 *       http://www.cs.wustl.edu/~schmidt/doc-center.html
 * and
 *       Distributed Object Computing Laboratory
 *       University of California at Irvine
 *       Irvine, CA
 *       USA
 * and
 *       Institute for Software Integrated Systems
 *       Vanderbilt University
 *       Nashville, TN
 *       USA
 *       http://www.isis.vanderbilt.edu/
 *
 * Information about TAO is available at:
 *     http://www.cs.wustl.edu/~schmidt/TAO.html
 **/

// TAO_IDL - Generated from
// be/be_codegen.cpp:152

#ifndef _TAO_IDL_SIMPLEC_STSRW3_H_
#define _TAO_IDL_SIMPLEC_STSRW3_H_

#include /**/ "ace/pre.h"


#include /**/ "ace/config-all.h"

#if !defined (ACE_LACKS_PRAGMA_ONCE)
# pragma once
#endif /* ACE_LACKS_PRAGMA_ONCE */


#include "tao/ORB.h"
#include "tao/SystemException.h"
#include "tao/Basic_Types.h"
#include "tao/ORB_Constants.h"
#include "tao/Object.h"
#include "tao/String_Manager_T.h"
#include "tao/Sequence_T.h"
#include "tao/Objref_VarOut_T.h"
#include "tao/Seq_Var_T.h"
#include "tao/Seq_Out_T.h"
#include "tao/VarOut_T.h"
#include "tao/Array_VarOut_T.h"
#include "tao/Arg_Traits_T.h"
#include "tao/Basic_Arguments.h"
#include "tao/Special_Basic_Arguments.h"
#include "tao/Any_Insert_Policy_T.h"
#include "tao/Basic_Argument_T.h"
#include "tao/Fixed_Size_Argument_T.h"
#include "tao/Var_Size_Argument_T.h"
#include "tao/Object_Argument_T.h"
#include "tao/UB_String_Arguments.h"
#include "tao/Fixed_Array_Argument_T.h"
#include "tao/Var_Array_Argument_T.h"
#include /**/ "tao/Version.h"
#include /**/ "tao/Versioned_Namespace.h"

#if TAO_MAJOR_VERSION != 2 || TAO_MINOR_VERSION != 2 || TAO_BETA_VERSION != 0
#error This file should be regenerated with TAO_IDL
#endif

#if defined (TAO_EXPORT_MACRO)
#undef TAO_EXPORT_MACRO
#endif
#define TAO_EXPORT_MACRO 

// TAO_IDL - Generated from
// be/be_visitor_root/root_ch.cpp:160
TAO_BEGIN_VERSIONED_NAMESPACE_DECL



namespace TAO
{
  template<typename T> class Narrow_Utils;
}
TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// be/be_visitor_module/module_ch.cpp:38

namespace simple
{

  // TAO_IDL - Generated from
  // be/be_visitor_typedef/typedef_ch.cpp:373

  typedef ::CORBA::Long TestTypedef;
  typedef ::CORBA::Long_out TestTypedef_out;

  // TAO_IDL - Generated from
  // be/be_visitor_typedef/typedef_ch.cpp:407

  typedef char * StringTypedef;
  typedef ::CORBA::String_var StringTypedef_var;
  typedef ::CORBA::String_out StringTypedef_out;

  // TAO_IDL - Generated from
  // be/be_visitor_sequence/sequence_ch.cpp:102

#if !defined (_SIMPLE_TESTSEQTYPEDEF_CH_)
#define _SIMPLE_TESTSEQTYPEDEF_CH_

  class TestSeqTypedef;

  typedef
    ::TAO_FixedSeq_Var_T<
        TestSeqTypedef
      >
    TestSeqTypedef_var;

  typedef
    ::TAO_Seq_Out_T<
        TestSeqTypedef
      >
    TestSeqTypedef_out;

  class  TestSeqTypedef
    : public
        ::TAO::unbounded_value_sequence<
            ::CORBA::Long
          >
  {
  public:
    TestSeqTypedef (void);
    TestSeqTypedef ( ::CORBA::ULong max);
    TestSeqTypedef (
      ::CORBA::ULong max,
      ::CORBA::ULong length,
      ::CORBA::Long* buffer,
      ::CORBA::Boolean release = false);
    TestSeqTypedef (const TestSeqTypedef &);
    virtual ~TestSeqTypedef (void);
    

    // TAO_IDL - Generated from
    // be/be_type.cpp:307

    
    typedef TestSeqTypedef_var _var_type;
    typedef TestSeqTypedef_out _out_type;
  };

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // be/be_visitor_sequence/sequence_ch.cpp:102

#if !defined (_SIMPLE_SEQOFTYPEDEFEDLONG_CH_)
#define _SIMPLE_SEQOFTYPEDEFEDLONG_CH_

  class SeqOfTypedefedLong;

  typedef
    ::TAO_FixedSeq_Var_T<
        SeqOfTypedefedLong
      >
    SeqOfTypedefedLong_var;

  typedef
    ::TAO_Seq_Out_T<
        SeqOfTypedefedLong
      >
    SeqOfTypedefedLong_out;

  class  SeqOfTypedefedLong
    : public
        ::TAO::unbounded_value_sequence<
            TestTypedef
          >
  {
  public:
    SeqOfTypedefedLong (void);
    SeqOfTypedefedLong ( ::CORBA::ULong max);
    SeqOfTypedefedLong (
      ::CORBA::ULong max,
      ::CORBA::ULong length,
      ::CORBA::Long* buffer,
      ::CORBA::Boolean release = false);
    SeqOfTypedefedLong (const SeqOfTypedefedLong &);
    virtual ~SeqOfTypedefedLong (void);
    

    // TAO_IDL - Generated from
    // be/be_type.cpp:307

    
    typedef SeqOfTypedefedLong_var _var_type;
    typedef SeqOfTypedefedLong_out _out_type;
  };

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // be/be_visitor_sequence/sequence_ch.cpp:102

#if !defined (_SIMPLE_STRINGSEQ_CH_)
#define _SIMPLE_STRINGSEQ_CH_

  class StringSeq;

  typedef
    ::TAO_VarSeq_Var_T<
        StringSeq
      >
    StringSeq_var;

  typedef
    ::TAO_Seq_Out_T<
        StringSeq
      >
    StringSeq_out;

  class  StringSeq
    : public
        ::TAO::unbounded_basic_string_sequence<char>
  {
  public:
    StringSeq (void);
    StringSeq ( ::CORBA::ULong max);
    StringSeq (
      ::CORBA::ULong max,
      ::CORBA::ULong length,
      ::CORBA::Char ** buffer,
      ::CORBA::Boolean release = false);
    StringSeq (const StringSeq &);
    virtual ~StringSeq (void);
    

    // TAO_IDL - Generated from
    // be/be_type.cpp:307

    
    typedef StringSeq_var _var_type;
    typedef StringSeq_out _out_type;
  };

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // be/be_visitor_constant/constant_ch.cpp:38

  const CORBA::Long ArrayBounds = 4;

  // TAO_IDL - Generated from
  // be/be_visitor_array/array_ch.cpp:54

  typedef ::CORBA::Long TestArrayTypedef[4];
  typedef ::CORBA::Long TestArrayTypedef_slice;
  struct TestArrayTypedef_tag {};
  

  typedef
    TAO_FixedArray_Var_T<
        TestArrayTypedef,
        TestArrayTypedef_slice,
        TestArrayTypedef_tag
      >
    TestArrayTypedef_var;

  typedef
    TestArrayTypedef
    TestArrayTypedef_out;

  typedef
    TAO_Array_Forany_T<
        TestArrayTypedef,
        TestArrayTypedef_slice,
        TestArrayTypedef_tag
      >
    TestArrayTypedef_forany;

  TAO_NAMESPACE_STORAGE_CLASS TestArrayTypedef_slice *
  TestArrayTypedef_alloc (void);

  TAO_NAMESPACE_STORAGE_CLASS void
  TestArrayTypedef_free (
      TestArrayTypedef_slice *_tao_slice);
  
  TAO_NAMESPACE_STORAGE_CLASS TestArrayTypedef_slice *
  TestArrayTypedef_dup (
      const TestArrayTypedef_slice *_tao_slice);
  
  TAO_NAMESPACE_STORAGE_CLASS void
  TestArrayTypedef_copy (
      TestArrayTypedef_slice *_tao_to,
      const TestArrayTypedef_slice *_tao_from);

  // TAO_IDL - Generated from
  // be/be_visitor_typedef/typedef_ch.cpp:182

  typedef TestArrayTypedef TestArrayTypedef2;
  typedef TestArrayTypedef_slice TestArrayTypedef2_slice;
  typedef TestArrayTypedef_var TestArrayTypedef2_var;
  typedef TestArrayTypedef_out TestArrayTypedef2_out;
  typedef TestArrayTypedef_tag TestArrayTypedef2_tag;
  typedef TestArrayTypedef_forany TestArrayTypedef2_forany;
  
  ACE_INLINE 
  TestArrayTypedef2_slice *
  TestArrayTypedef2_alloc (void);
  
  ACE_INLINE 
  TestArrayTypedef2_slice *
  TestArrayTypedef2_dup (
      const TestArrayTypedef2_slice *_tao_slice);
  
  ACE_INLINE 
  void TestArrayTypedef2_copy (
      TestArrayTypedef2_slice *_tao_to,
      const TestArrayTypedef2_slice *_tao_from);
  
  ACE_INLINE 
  void TestArrayTypedef2_free (
      TestArrayTypedef2_slice *_tao_slice);

  // TAO_IDL - Generated from
  // be/be_visitor_array/array_ch.cpp:54

  typedef ::TAO::String_Manager TestStringArray[4];
  typedef ::TAO::String_Manager TestStringArray_slice;
  struct TestStringArray_tag {};
  

  typedef
    TAO_VarArray_Var_T<
        TestStringArray,
        TestStringArray_slice,
        TestStringArray_tag
      >
    TestStringArray_var;

  typedef
    TAO_Array_Out_T<
        TestStringArray,
        TestStringArray_var,
        TestStringArray_slice,
        TestStringArray_tag
      >
    TestStringArray_out;

  typedef
    TAO_Array_Forany_T<
        TestStringArray,
        TestStringArray_slice,
        TestStringArray_tag
      >
    TestStringArray_forany;

  TAO_NAMESPACE_STORAGE_CLASS TestStringArray_slice *
  TestStringArray_alloc (void);

  TAO_NAMESPACE_STORAGE_CLASS void
  TestStringArray_free (
      TestStringArray_slice *_tao_slice);
  
  TAO_NAMESPACE_STORAGE_CLASS TestStringArray_slice *
  TestStringArray_dup (
      const TestStringArray_slice *_tao_slice);
  
  TAO_NAMESPACE_STORAGE_CLASS void
  TestStringArray_copy (
      TestStringArray_slice *_tao_to,
      const TestStringArray_slice *_tao_from);

  // TAO_IDL - Generated from
  // be/be_visitor_sequence/sequence_ch.cpp:102

#if !defined (_SIMPLE_STRINGSEQSEQ_CH_)
#define _SIMPLE_STRINGSEQSEQ_CH_

  class StringSeqSeq;

  typedef
    ::TAO_VarSeq_Var_T<
        StringSeqSeq
      >
    StringSeqSeq_var;

  typedef
    ::TAO_Seq_Out_T<
        StringSeqSeq
      >
    StringSeqSeq_out;

  class  StringSeqSeq
    : public
        ::TAO::unbounded_value_sequence<
            StringSeq
          >
  {
  public:
    StringSeqSeq (void);
    StringSeqSeq ( ::CORBA::ULong max);
    StringSeqSeq (
      ::CORBA::ULong max,
      ::CORBA::ULong length,
      StringSeq* buffer,
      ::CORBA::Boolean release = false);
    StringSeqSeq (const StringSeqSeq &);
    virtual ~StringSeqSeq (void);
    

    // TAO_IDL - Generated from
    // be/be_type.cpp:307

    
    typedef StringSeqSeq_var _var_type;
    typedef StringSeqSeq_out _out_type;
  };

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // be/be_visitor_sequence/sequence_ch.cpp:102

#if !defined (_SIMPLE_STRINGSEQSEQSEQ_CH_)
#define _SIMPLE_STRINGSEQSEQSEQ_CH_

  class StringSeqSeqSeq;

  typedef
    ::TAO_VarSeq_Var_T<
        StringSeqSeqSeq
      >
    StringSeqSeqSeq_var;

  typedef
    ::TAO_Seq_Out_T<
        StringSeqSeqSeq
      >
    StringSeqSeqSeq_out;

  class  StringSeqSeqSeq
    : public
        ::TAO::unbounded_value_sequence<
            StringSeqSeq
          >
  {
  public:
    StringSeqSeqSeq (void);
    StringSeqSeqSeq ( ::CORBA::ULong max);
    StringSeqSeqSeq (
      ::CORBA::ULong max,
      ::CORBA::ULong length,
      StringSeqSeq* buffer,
      ::CORBA::Boolean release = false);
    StringSeqSeqSeq (const StringSeqSeqSeq &);
    virtual ~StringSeqSeqSeq (void);
    

    // TAO_IDL - Generated from
    // be/be_type.cpp:307

    
    typedef StringSeqSeqSeq_var _var_type;
    typedef StringSeqSeqSeq_out _out_type;
  };

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // be/be_visitor_sequence/sequence_ch.cpp:102

#if !defined (_SIMPLE_LONGSEQSEQ_CH_)
#define _SIMPLE_LONGSEQSEQ_CH_

  class LongSeqSeq;

  typedef
    ::TAO_VarSeq_Var_T<
        LongSeqSeq
      >
    LongSeqSeq_var;

  typedef
    ::TAO_Seq_Out_T<
        LongSeqSeq
      >
    LongSeqSeq_out;

  class  LongSeqSeq
    : public
        ::TAO::unbounded_value_sequence<
            TestSeqTypedef
          >
  {
  public:
    LongSeqSeq (void);
    LongSeqSeq ( ::CORBA::ULong max);
    LongSeqSeq (
      ::CORBA::ULong max,
      ::CORBA::ULong length,
      TestSeqTypedef* buffer,
      ::CORBA::Boolean release = false);
    LongSeqSeq (const LongSeqSeq &);
    virtual ~LongSeqSeq (void);
    

    // TAO_IDL - Generated from
    // be/be_type.cpp:307

    
    typedef LongSeqSeq_var _var_type;
    typedef LongSeqSeq_out _out_type;
  };

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // be/be_visitor_sequence/sequence_ch.cpp:102

#if !defined (_SIMPLE_LONGSEQSEQSEQ_CH_)
#define _SIMPLE_LONGSEQSEQSEQ_CH_

  class LongSeqSeqSeq;

  typedef
    ::TAO_VarSeq_Var_T<
        LongSeqSeqSeq
      >
    LongSeqSeqSeq_var;

  typedef
    ::TAO_Seq_Out_T<
        LongSeqSeqSeq
      >
    LongSeqSeqSeq_out;

  class  LongSeqSeqSeq
    : public
        ::TAO::unbounded_value_sequence<
            LongSeqSeq
          >
  {
  public:
    LongSeqSeqSeq (void);
    LongSeqSeqSeq ( ::CORBA::ULong max);
    LongSeqSeqSeq (
      ::CORBA::ULong max,
      ::CORBA::ULong length,
      LongSeqSeq* buffer,
      ::CORBA::Boolean release = false);
    LongSeqSeqSeq (const LongSeqSeqSeq &);
    virtual ~LongSeqSeqSeq (void);
    

    // TAO_IDL - Generated from
    // be/be_type.cpp:307

    
    typedef LongSeqSeqSeq_var _var_type;
    typedef LongSeqSeqSeq_out _out_type;
  };

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // be/be_type.cpp:261

  struct TestStruct;

  typedef
    ::TAO_Var_Var_T<
        TestStruct
      >
    TestStruct_var;

  typedef
    ::TAO_Out_T<
        TestStruct
      >
    TestStruct_out;

  // TAO_IDL - Generated from
  // be/be_visitor_structure/structure_ch.cpp:51

  struct  TestStruct
  {

    // TAO_IDL - Generated from
    // be/be_type.cpp:307

    
    typedef TestStruct_var _var_type;
    typedef TestStruct_out _out_type;
    
    ::CORBA::Long m1;
    ::CORBA::ULong m2;
    simple::TestSeqTypedef seq1;
    simple::SeqOfTypedefedLong seq2;
    ::TAO::String_Manager st;
  };

  // TAO_IDL - Generated from
  // be/be_visitor_sequence/sequence_ch.cpp:102

#if !defined (_SIMPLE_TESTSTRUCTSEQUENCE_CH_)
#define _SIMPLE_TESTSTRUCTSEQUENCE_CH_

  class TestStructSequence;

  typedef
    ::TAO_VarSeq_Var_T<
        TestStructSequence
      >
    TestStructSequence_var;

  typedef
    ::TAO_Seq_Out_T<
        TestStructSequence
      >
    TestStructSequence_out;

  class  TestStructSequence
    : public
        ::TAO::unbounded_value_sequence<
            TestStruct
          >
  {
  public:
    TestStructSequence (void);
    TestStructSequence ( ::CORBA::ULong max);
    TestStructSequence (
      ::CORBA::ULong max,
      ::CORBA::ULong length,
      TestStruct* buffer,
      ::CORBA::Boolean release = false);
    TestStructSequence (const TestStructSequence &);
    virtual ~TestStructSequence (void);
    

    // TAO_IDL - Generated from
    // be/be_type.cpp:307

    
    typedef TestStructSequence_var _var_type;
    typedef TestStructSequence_out _out_type;
  };

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // be/be_visitor_array/array_ch.cpp:54

  typedef TestStruct TestStructArray[4];
  typedef TestStruct TestStructArray_slice;
  struct TestStructArray_tag {};
  

  typedef
    TAO_VarArray_Var_T<
        TestStructArray,
        TestStructArray_slice,
        TestStructArray_tag
      >
    TestStructArray_var;

  typedef
    TAO_Array_Out_T<
        TestStructArray,
        TestStructArray_var,
        TestStructArray_slice,
        TestStructArray_tag
      >
    TestStructArray_out;

  typedef
    TAO_Array_Forany_T<
        TestStructArray,
        TestStructArray_slice,
        TestStructArray_tag
      >
    TestStructArray_forany;

  TAO_NAMESPACE_STORAGE_CLASS TestStructArray_slice *
  TestStructArray_alloc (void);

  TAO_NAMESPACE_STORAGE_CLASS void
  TestStructArray_free (
      TestStructArray_slice *_tao_slice);
  
  TAO_NAMESPACE_STORAGE_CLASS TestStructArray_slice *
  TestStructArray_dup (
      const TestStructArray_slice *_tao_slice);
  
  TAO_NAMESPACE_STORAGE_CLASS void
  TestStructArray_copy (
      TestStructArray_slice *_tao_to,
      const TestStructArray_slice *_tao_from);

  // TAO_IDL - Generated from
  // be/be_type.cpp:261

  struct TestNestedStruct;

  typedef
    ::TAO_Var_Var_T<
        TestNestedStruct
      >
    TestNestedStruct_var;

  typedef
    ::TAO_Out_T<
        TestNestedStruct
      >
    TestNestedStruct_out;

  // TAO_IDL - Generated from
  // be/be_visitor_structure/structure_ch.cpp:51

  struct  TestNestedStruct
  {

    // TAO_IDL - Generated from
    // be/be_type.cpp:307

    
    typedef TestNestedStruct_var _var_type;
    typedef TestNestedStruct_out _out_type;
    
    simple::TestStruct m;
    ::TAO::String_Manager str;
    simple::TestArrayTypedef arr;
    simple::StringSeqSeq sss;
    simple::StringSeqSeqSeq ssss;
    simple::LongSeqSeq lss;
    simple::LongSeqSeqSeq lsss;
  };

  // TAO_IDL - Generated from
  // be/be_visitor_constant/constant_ch.cpp:38

  const CORBA::Long TestConstLong = 0;

  // TAO_IDL - Generated from
  // be/be_visitor_constant/constant_ch.cpp:38

  const CORBA::ULong TIMESTAMP_INVALID_NSEC = 4294967295U;

  // TAO_IDL - Generated from
  // be/be_visitor_constant/constant_ch.cpp:38

  const CORBA::Float TestConstFloat = 3.140000F;

  // TAO_IDL - Generated from
  // be/be_visitor_constant/constant_ch.cpp:38

  const CORBA::Double TestConstDouble =                     2.17;

  // TAO_IDL - Generated from
  // be/be_visitor_constant/constant_ch.cpp:38

  const CORBA::Boolean TestConstBool = true;

  // TAO_IDL - Generated from
  // be/be_visitor_constant/constant_ch.cpp:38

  const char *const TestConstString = "Hello World.";

  // TAO_IDL - Generated from
  // be/be_visitor_constant/constant_ch.cpp:38

  const CORBA::Long TestConstTypedef = 42;

  // TAO_IDL - Generated from
  // be/be_visitor_constant/constant_ch.cpp:38

  const CORBA::Char TestConstChar = 'c';

  // TAO_IDL - Generated from
  // be/be_visitor_constant/constant_ch.cpp:38

  const CORBA::WChar TestConstWchar = L'A';

  // TAO_IDL - Generated from
  // be/be_visitor_enum/enum_ch.cpp:47

  enum TestEnum
  {
    a,
    b,
    c,
    d,
    e
  };

  typedef TestEnum &TestEnum_out;

  // TAO_IDL - Generated from
  // be/be_type.cpp:261

  class TestUnion1;

  typedef
    ::TAO_Fixed_Var_T<
        TestUnion1
      >
    TestUnion1_var;

  typedef
    TestUnion1 &
    TestUnion1_out;

  class  TestUnion1
  {
  public:
    TestUnion1 (void);
    TestUnion1 (const TestUnion1 &);
    ~TestUnion1 (void);

    TestUnion1 &operator= (const TestUnion1 &);

    // TAO_IDL - Generated from
    // be/be_visitor_union/discriminant_ch.cpp:70

    void _d (simple::TestEnum);
    simple::TestEnum _d (void) const;

    // TAO_IDL - Generated from
    // be/be_type.cpp:307

    
    typedef TestUnion1_var _var_type;
    typedef TestUnion1_out _out_type;

    // TAO_IDL - Generated from
    // be/be_visitor_union_branch/public_ch.cpp:452

    void o ( ::CORBA::Octet);
    ::CORBA::Octet o (void) const;

    // TAO_IDL - Generated from
    // be/be_visitor_union_branch/public_ch.cpp:452

    void s ( ::CORBA::Short);
    ::CORBA::Short s (void) const;

    // TAO_IDL - Generated from
    // be/be_visitor_union_branch/public_ch.cpp:452

    void l ( ::CORBA::Long);
    ::CORBA::Long l (void) const;

    // TAO_IDL - Generated from
    // be/be_visitor_union_branch/public_ch.cpp:452

    void n ( ::CORBA::Boolean);
    ::CORBA::Boolean n (void) const;

    // TAO_IDL - Generated from
    // be/be_visitor_union_branch/public_ch.cpp:452

    void u ( ::CORBA::Double);
    ::CORBA::Double u (void) const;

    // TAO_IDL - Generated from
    // be/be_visitor_union/union_ch.cpp:124

    void _default (void);
  private:
    simple::TestEnum disc_;

    union
    {
      // TAO_IDL - Generated from
      // be/be_visitor_union_branch/private_ch.cpp:380
      ::CORBA::Octet o_;
      // TAO_IDL - Generated from
      // be/be_visitor_union_branch/private_ch.cpp:380
      ::CORBA::Short s_;
      // TAO_IDL - Generated from
      // be/be_visitor_union_branch/private_ch.cpp:380
      ::CORBA::Long l_;
      // TAO_IDL - Generated from
      // be/be_visitor_union_branch/private_ch.cpp:380
      ::CORBA::Boolean n_;
      // TAO_IDL - Generated from
      // be/be_visitor_union_branch/private_ch.cpp:380
      ::CORBA::Double u_;
    } u_;

    /// TAO extension - frees any allocated storage.
    void _reset (void);
  };

  // TAO_IDL - Generated from
  // be/be_type.cpp:261

  class TestUnion2;

  typedef
    ::TAO_Var_Var_T<
        TestUnion2
      >
    TestUnion2_var;

  typedef
    ::TAO_Out_T<
        TestUnion2
      >
    TestUnion2_out;

  class  TestUnion2
  {
  public:
    TestUnion2 (void);
    TestUnion2 (const TestUnion2 &);
    ~TestUnion2 (void);

    TestUnion2 &operator= (const TestUnion2 &);

    // TAO_IDL - Generated from
    // be/be_visitor_union/discriminant_ch.cpp:103

    void _d ( ::CORBA::Short);
    ::CORBA::Short _d (void) const;

    // TAO_IDL - Generated from
    // be/be_type.cpp:307

    
    typedef TestUnion2_var _var_type;
    typedef TestUnion2_out _out_type;

    // TAO_IDL - Generated from
    // be/be_visitor_union_branch/public_ch.cpp:583

    void s (char *);
    void s (const char *);
    void s (const ::CORBA::String_var&);
    const char *s (void) const;

    // TAO_IDL - Generated from
    // be/be_visitor_union_branch/public_ch.cpp:659

    void t (const simple::TestStruct &);
    const simple::TestStruct &t (void) const;
    simple::TestStruct &t (void);

    // TAO_IDL - Generated from
    // be/be_visitor_union_branch/public_ch.cpp:551

    void q (const simple::TestSeqTypedef &);
    const simple::TestSeqTypedef &q (void) const;
    simple::TestSeqTypedef &q (void);

    // TAO_IDL - Generated from
    // be/be_visitor_union_branch/public_ch.cpp:583

    void d (char *);
    void d (const char *);
    void d (const ::CORBA::String_var&);
    const char *d (void) const;

    // TAO_IDL - Generated from
    // be/be_visitor_union_branch/public_ch.cpp:192

    void e (simple::TestEnum);
    simple::TestEnum e (void) const;
  private:
    ::CORBA::Short disc_;

    union
    {
      // TAO_IDL - Generated from
      // be/be_visitor_union_branch/private_ch.cpp:477
      char *s_;
      // TAO_IDL - Generated from
      // be/be_visitor_union_branch/private_ch.cpp:522
      simple::TestStruct *t_;
      // TAO_IDL - Generated from
      // be/be_visitor_union_branch/private_ch.cpp:447
      simple::TestSeqTypedef *q_;
      // TAO_IDL - Generated from
      // be/be_visitor_union_branch/private_ch.cpp:477
      char *d_;
      // TAO_IDL - Generated from
      // be/be_visitor_union_branch/private_ch.cpp:143
      simple::TestEnum e_;
    } u_;

    /// TAO extension - frees any allocated storage.
    void _reset (void);
  };

  // TAO_IDL - Generated from
  // be/be_type.cpp:261

  class TestUnion4;

  typedef
    ::TAO_Fixed_Var_T<
        TestUnion4
      >
    TestUnion4_var;

  typedef
    TestUnion4 &
    TestUnion4_out;

  class  TestUnion4
  {
  public:
    TestUnion4 (void);
    TestUnion4 (const TestUnion4 &);
    ~TestUnion4 (void);

    TestUnion4 &operator= (const TestUnion4 &);

    // TAO_IDL - Generated from
    // be/be_visitor_union/discriminant_ch.cpp:103

    void _d ( ::CORBA::Boolean);
    ::CORBA::Boolean _d (void) const;

    // TAO_IDL - Generated from
    // be/be_type.cpp:307

    
    typedef TestUnion4_var _var_type;
    typedef TestUnion4_out _out_type;

    // TAO_IDL - Generated from
    // be/be_visitor_union_branch/public_ch.cpp:452

    void c ( ::CORBA::Char);
    ::CORBA::Char c (void) const;

    // TAO_IDL - Generated from
    // be/be_visitor_union/union_ch.cpp:124

    void _default (void);
  private:
    ::CORBA::Boolean disc_;

    union
    {
      // TAO_IDL - Generated from
      // be/be_visitor_union_branch/private_ch.cpp:380
      ::CORBA::Char c_;
    } u_;

    /// TAO extension - frees any allocated storage.
    void _reset (void);
  };

  // TAO_IDL - Generated from
  // be/be_visitor_sequence/sequence_ch.cpp:102

#if !defined (_SIMPLE_ENUMSEQ_CH_)
#define _SIMPLE_ENUMSEQ_CH_

  class EnumSeq;

  typedef
    ::TAO_FixedSeq_Var_T<
        EnumSeq
      >
    EnumSeq_var;

  typedef
    ::TAO_Seq_Out_T<
        EnumSeq
      >
    EnumSeq_out;

  class  EnumSeq
    : public
        ::TAO::unbounded_value_sequence<
            TestEnum
          >
  {
  public:
    EnumSeq (void);
    EnumSeq ( ::CORBA::ULong max);
    EnumSeq (
      ::CORBA::ULong max,
      ::CORBA::ULong length,
      TestEnum* buffer,
      ::CORBA::Boolean release = false);
    EnumSeq (const EnumSeq &);
    virtual ~EnumSeq (void);
    

    // TAO_IDL - Generated from
    // be/be_type.cpp:307

    
    typedef EnumSeq_var _var_type;
    typedef EnumSeq_out _out_type;
  };

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // be/be_visitor_array/array_ch.cpp:54

  typedef TestEnum EnumArray[4];
  typedef TestEnum EnumArray_slice;
  struct EnumArray_tag {};
  

  typedef
    TAO_FixedArray_Var_T<
        EnumArray,
        EnumArray_slice,
        EnumArray_tag
      >
    EnumArray_var;

  typedef
    EnumArray
    EnumArray_out;

  typedef
    TAO_Array_Forany_T<
        EnumArray,
        EnumArray_slice,
        EnumArray_tag
      >
    EnumArray_forany;

  TAO_NAMESPACE_STORAGE_CLASS EnumArray_slice *
  EnumArray_alloc (void);

  TAO_NAMESPACE_STORAGE_CLASS void
  EnumArray_free (
      EnumArray_slice *_tao_slice);
  
  TAO_NAMESPACE_STORAGE_CLASS EnumArray_slice *
  EnumArray_dup (
      const EnumArray_slice *_tao_slice);
  
  TAO_NAMESPACE_STORAGE_CLASS void
  EnumArray_copy (
      EnumArray_slice *_tao_to,
      const EnumArray_slice *_tao_from);

  // TAO_IDL - Generated from
  // be/be_type.cpp:261

  struct TestStructWithEnum;

  typedef
    ::TAO_Var_Var_T<
        TestStructWithEnum
      >
    TestStructWithEnum_var;

  typedef
    ::TAO_Out_T<
        TestStructWithEnum
      >
    TestStructWithEnum_out;

  // TAO_IDL - Generated from
  // be/be_visitor_structure/structure_ch.cpp:51

  struct  TestStructWithEnum
  {

    // TAO_IDL - Generated from
    // be/be_type.cpp:307

    
    typedef TestStructWithEnum_var _var_type;
    typedef TestStructWithEnum_out _out_type;
    
    ::CORBA::Long count;
    simple::TestEnum which;
    simple::EnumSeq lotsOfEm;
    

    simple::TestUnion1 fixedUnion;
    

    simple::TestUnion2 variableUnion;
  };

  // TAO_IDL - Generated from
  // be/be_interface.cpp:751

#if !defined (_SIMPLE_TESTINTERF__VAR_OUT_CH_)
#define _SIMPLE_TESTINTERF__VAR_OUT_CH_

  class TestInterf;
  typedef TestInterf *TestInterf_ptr;

  typedef
    TAO_Objref_Var_T<
        TestInterf
      >
    TestInterf_var;
  
  typedef
    TAO_Objref_Out_T<
        TestInterf
      >
    TestInterf_out;

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // be/be_visitor_interface/interface_ch.cpp:43

  class  TestInterf
    : public virtual ::CORBA::Object
  {
  public:
    friend class TAO::Narrow_Utils<TestInterf>;

    // TAO_IDL - Generated from
    // be/be_type.cpp:307

    typedef TestInterf_ptr _ptr_type;
    typedef TestInterf_var _var_type;
    typedef TestInterf_out _out_type;

    // The static operations.
    static TestInterf_ptr _duplicate (TestInterf_ptr obj);

    static void _tao_release (TestInterf_ptr obj);

    static TestInterf_ptr _narrow (::CORBA::Object_ptr obj);
    static TestInterf_ptr _unchecked_narrow (::CORBA::Object_ptr obj);
    static TestInterf_ptr _nil (void);

    virtual ::simple::TestArrayTypedef_slice * op1 (
      ::simple::TestEnum p1,
      ::CORBA::UShort & p2,
      ::simple::TestSeqTypedef_out p3,
      ::CORBA::String_out p4);

    virtual ::simple::TestUnion4 opu (
      const ::simple::TestUnion1 & p1,
      ::simple::TestUnion2 & p2,
      ::simple::TestUnion1_out p4);

    virtual ::CORBA::Long attr1 (
      void);

    virtual void attr1 (
      ::CORBA::Long attr1);

    // TAO_IDL - Generated from
    // be/be_visitor_interface/interface_ch.cpp:140

    virtual ::CORBA::Boolean _is_a (const char *type_id);
    virtual const char* _interface_repository_id (void) const;
    virtual ::CORBA::Boolean marshal (TAO_OutputCDR &cdr);
  
  protected:
    // Concrete interface only.
    TestInterf (void);

    // Concrete non-local interface only.
    TestInterf (
        ::IOP::IOR *ior,
        TAO_ORB_Core *orb_core);
    
    // Non-local interface only.
    TestInterf (
        TAO_Stub *objref,
        ::CORBA::Boolean _tao_collocated = false,
        TAO_Abstract_ServantBase *servant = 0,
        TAO_ORB_Core *orb_core = 0);

    virtual ~TestInterf (void);
  
  private:
    // Private and unimplemented for concrete interfaces.
    TestInterf (const TestInterf &);

    void operator= (const TestInterf &);
  };

  // TAO_IDL - Generated from
  // be/be_visitor_sequence/sequence_ch.cpp:102

#if !defined (_SIMPLE_TESTUNION2SEQ_CH_)
#define _SIMPLE_TESTUNION2SEQ_CH_

  class TestUnion2Seq;

  typedef
    ::TAO_VarSeq_Var_T<
        TestUnion2Seq
      >
    TestUnion2Seq_var;

  typedef
    ::TAO_Seq_Out_T<
        TestUnion2Seq
      >
    TestUnion2Seq_out;

  class  TestUnion2Seq
    : public
        ::TAO::unbounded_value_sequence<
            TestUnion2
          >
  {
  public:
    TestUnion2Seq (void);
    TestUnion2Seq ( ::CORBA::ULong max);
    TestUnion2Seq (
      ::CORBA::ULong max,
      ::CORBA::ULong length,
      TestUnion2* buffer,
      ::CORBA::Boolean release = false);
    TestUnion2Seq (const TestUnion2Seq &);
    virtual ~TestUnion2Seq (void);
    

    // TAO_IDL - Generated from
    // be/be_type.cpp:307

    
    typedef TestUnion2Seq_var _var_type;
    typedef TestUnion2Seq_out _out_type;
  };

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // be/be_type.cpp:261

  class TestUnion3;

  typedef
    ::TAO_Var_Var_T<
        TestUnion3
      >
    TestUnion3_var;

  typedef
    ::TAO_Out_T<
        TestUnion3
      >
    TestUnion3_out;

  class  TestUnion3
  {
  public:
    TestUnion3 (void);
    TestUnion3 (const TestUnion3 &);
    ~TestUnion3 (void);

    TestUnion3 &operator= (const TestUnion3 &);

    // TAO_IDL - Generated from
    // be/be_visitor_union/discriminant_ch.cpp:70

    void _d (simple::TestEnum);
    simple::TestEnum _d (void) const;

    // TAO_IDL - Generated from
    // be/be_type.cpp:307

    
    typedef TestUnion3_var _var_type;
    typedef TestUnion3_out _out_type;

    // TAO_IDL - Generated from
    // be/be_visitor_union_branch/public_ch.cpp:129

    void sa (simple::TestStructArray);
    simple::TestStructArray_slice * sa (void) const;

    // TAO_IDL - Generated from
    // be/be_visitor_union_branch/public_ch.cpp:236

    void obj (simple::TestInterf_ptr);
    simple::TestInterf_ptr obj (void) const;

    // TAO_IDL - Generated from
    // be/be_visitor_union_branch/public_ch.cpp:551

    void us (const simple::TestUnion2Seq &);
    const simple::TestUnion2Seq &us (void) const;
    simple::TestUnion2Seq &us (void);

    // TAO_IDL - Generated from
    // be/be_visitor_union_branch/public_ch.cpp:452

    void fp ( ::CORBA::Double);
    ::CORBA::Double fp (void) const;
  private:
    simple::TestEnum disc_;

    union
    {
      // TAO_IDL - Generated from
      // be/be_visitor_union_branch/private_ch.cpp:93
      simple::TestStructArray_slice *sa_;
      // TAO_IDL - Generated from
      // be/be_visitor_union_branch/private_ch.cpp:182
      simple::TestInterf_var *obj_;
      // TAO_IDL - Generated from
      // be/be_visitor_union_branch/private_ch.cpp:447
      simple::TestUnion2Seq *us_;
      // TAO_IDL - Generated from
      // be/be_visitor_union_branch/private_ch.cpp:380
      ::CORBA::Double fp_;
    } u_;

    /// TAO extension - frees any allocated storage.
    void _reset (void);
  };

  // TAO_IDL - Generated from
  // be/be_interface.cpp:751

#if !defined (_SIMPLE_TESTINTERF2__VAR_OUT_CH_)
#define _SIMPLE_TESTINTERF2__VAR_OUT_CH_

  class TestInterf2;
  typedef TestInterf2 *TestInterf2_ptr;

  typedef
    TAO_Objref_Var_T<
        TestInterf2
      >
    TestInterf2_var;
  
  typedef
    TAO_Objref_Out_T<
        TestInterf2
      >
    TestInterf2_out;

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // be/be_visitor_interface/interface_ch.cpp:43

  class  TestInterf2
    : public virtual ::simple::TestInterf
  
  {
  public:
    friend class TAO::Narrow_Utils<TestInterf2>;

    // TAO_IDL - Generated from
    // be/be_type.cpp:307

    typedef TestInterf2_ptr _ptr_type;
    typedef TestInterf2_var _var_type;
    typedef TestInterf2_out _out_type;

    // The static operations.
    static TestInterf2_ptr _duplicate (TestInterf2_ptr obj);

    static void _tao_release (TestInterf2_ptr obj);

    static TestInterf2_ptr _narrow (::CORBA::Object_ptr obj);
    static TestInterf2_ptr _unchecked_narrow (::CORBA::Object_ptr obj);
    static TestInterf2_ptr _nil (void);

    virtual ::CORBA::Long op2 (
      const ::simple::TestArrayTypedef p1,
      const ::simple::LongSeqSeq & p2);

    // TAO_IDL - Generated from
    // be/be_visitor_interface/interface_ch.cpp:140

    virtual ::CORBA::Boolean _is_a (const char *type_id);
    virtual const char* _interface_repository_id (void) const;
    virtual ::CORBA::Boolean marshal (TAO_OutputCDR &cdr);
  
  protected:
    // Concrete interface only.
    TestInterf2 (void);

    // Concrete non-local interface only.
    TestInterf2 (
        ::IOP::IOR *ior,
        TAO_ORB_Core *orb_core);
    
    // Non-local interface only.
    TestInterf2 (
        TAO_Stub *objref,
        ::CORBA::Boolean _tao_collocated = false,
        TAO_Abstract_ServantBase *servant = 0,
        TAO_ORB_Core *orb_core = 0);

    virtual ~TestInterf2 (void);
  
  private:
    // Private and unimplemented for concrete interfaces.
    TestInterf2 (const TestInterf2 &);

    void operator= (const TestInterf2 &);
  };

  // TAO_IDL - Generated from
  // be/be_interface.cpp:751

#if !defined (_SIMPLE_TESTINTERF3__VAR_OUT_CH_)
#define _SIMPLE_TESTINTERF3__VAR_OUT_CH_

  class TestInterf3;
  typedef TestInterf3 *TestInterf3_ptr;

  typedef
    TAO_Objref_Var_T<
        TestInterf3
      >
    TestInterf3_var;
  
  typedef
    TAO_Objref_Out_T<
        TestInterf3
      >
    TestInterf3_out;

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // be/be_visitor_interface/interface_ch.cpp:43

  class  TestInterf3
    : public virtual ::simple::TestInterf2
  
  {
  public:
    friend class TAO::Narrow_Utils<TestInterf3>;

    // TAO_IDL - Generated from
    // be/be_type.cpp:307

    typedef TestInterf3_ptr _ptr_type;
    typedef TestInterf3_var _var_type;
    typedef TestInterf3_out _out_type;

    // The static operations.
    static TestInterf3_ptr _duplicate (TestInterf3_ptr obj);

    static void _tao_release (TestInterf3_ptr obj);

    static TestInterf3_ptr _narrow (::CORBA::Object_ptr obj);
    static TestInterf3_ptr _unchecked_narrow (::CORBA::Object_ptr obj);
    static TestInterf3_ptr _nil (void);

    virtual void op3 (
      const ::simple::TestNestedStruct & p1);

    // TAO_IDL - Generated from
    // be/be_visitor_interface/interface_ch.cpp:140

    virtual ::CORBA::Boolean _is_a (const char *type_id);
    virtual const char* _interface_repository_id (void) const;
    virtual ::CORBA::Boolean marshal (TAO_OutputCDR &cdr);
  
  protected:
    // Concrete interface only.
    TestInterf3 (void);

    // Concrete non-local interface only.
    TestInterf3 (
        ::IOP::IOR *ior,
        TAO_ORB_Core *orb_core);
    
    // Non-local interface only.
    TestInterf3 (
        TAO_Stub *objref,
        ::CORBA::Boolean _tao_collocated = false,
        TAO_Abstract_ServantBase *servant = 0,
        TAO_ORB_Core *orb_core = 0);

    virtual ~TestInterf3 (void);
  
  private:
    // Private and unimplemented for concrete interfaces.
    TestInterf3 (const TestInterf3 &);

    void operator= (const TestInterf3 &);
  };

  // TAO_IDL - Generated from
  // be/be_interface.cpp:751

#if !defined (_SIMPLE_TESTLI__VAR_OUT_CH_)
#define _SIMPLE_TESTLI__VAR_OUT_CH_

  class TestLI;
  typedef TestLI *TestLI_ptr;

  typedef
    TAO_Objref_Var_T<
        TestLI
      >
    TestLI_var;
  
  typedef
    TAO_Objref_Out_T<
        TestLI
      >
    TestLI_out;

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // be/be_visitor_interface/interface_ch.cpp:43

  class  TestLI
    : public virtual ::CORBA::Object
  {
  public:

    // TAO_IDL - Generated from
    // be/be_type.cpp:307

    typedef TestLI_ptr _ptr_type;
    typedef TestLI_var _var_type;
    typedef TestLI_out _out_type;

    // The static operations.
    static TestLI_ptr _duplicate (TestLI_ptr obj);

    static void _tao_release (TestLI_ptr obj);

    static TestLI_ptr _narrow (::CORBA::Object_ptr obj);
    static TestLI_ptr _unchecked_narrow (::CORBA::Object_ptr obj);
    static TestLI_ptr _nil (void);

    virtual ::CORBA::Boolean localOp (
      ::simple::EnumSeq & p1,
      ::simple::TestStructSequence_out p2) = 0;

    virtual ::CORBA::Boolean localOp2 (
      ::simple::TestStructSequence & s1) = 0;

    virtual ::simple::EnumSeq * returnASequence (
      ::CORBA::Short_out p1,
      ::simple::TestStruct & p2) = 0;

    virtual void primitive (
      ::CORBA::Boolean & p1,
      ::CORBA::Char_out p2,
      ::CORBA::Octet & p3,
      ::CORBA::Short_out p4,
      ::CORBA::ULong & p5,
      ::CORBA::LongLong_out p6,
      ::CORBA::Float & p7,
      ::CORBA::Double_out p8) = 0;

    virtual ::CORBA::Long attr1 (
      void) = 0;

    virtual void attr1 (
      ::CORBA::Long attr1) = 0;

    virtual ::CORBA::Double attr2 (
      void) = 0;

    virtual void attr2 (
      ::CORBA::Double attr2) = 0;

    // TAO_IDL - Generated from
    // be/be_visitor_interface/interface_ch.cpp:140

    virtual ::CORBA::Boolean _is_a (const char *type_id);
    virtual const char* _interface_repository_id (void) const;
    virtual ::CORBA::Boolean marshal (TAO_OutputCDR &cdr);
  
  protected:
    // Abstract or local interface only.
    TestLI (void);

    

    virtual ~TestLI (void);
  
  private:
    // Private and unimplemented for concrete interfaces.
    TestLI (const TestLI &);

    void operator= (const TestLI &);
  };

  // TAO_IDL - Generated from
  // be/be_interface.cpp:751

#if !defined (_SIMPLE_LOCAL2__VAR_OUT_CH_)
#define _SIMPLE_LOCAL2__VAR_OUT_CH_

  class Local2;
  typedef Local2 *Local2_ptr;

  typedef
    TAO_Objref_Var_T<
        Local2
      >
    Local2_var;
  
  typedef
    TAO_Objref_Out_T<
        Local2
      >
    Local2_out;

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // be/be_visitor_interface/interface_ch.cpp:43

  class  Local2
    : public virtual ::simple::TestLI
  
  {
  public:

    // TAO_IDL - Generated from
    // be/be_type.cpp:307

    typedef Local2_ptr _ptr_type;
    typedef Local2_var _var_type;
    typedef Local2_out _out_type;

    // The static operations.
    static Local2_ptr _duplicate (Local2_ptr obj);

    static void _tao_release (Local2_ptr obj);

    static Local2_ptr _narrow (::CORBA::Object_ptr obj);
    static Local2_ptr _unchecked_narrow (::CORBA::Object_ptr obj);
    static Local2_ptr _nil (void);

    virtual ::simple::TestLI_ptr op (
      ::simple::TestLI_ptr p1,
      ::simple::TestLI_ptr & p2,
      ::simple::TestLI_out p3) = 0;

    // TAO_IDL - Generated from
    // be/be_visitor_interface/interface_ch.cpp:140

    virtual ::CORBA::Boolean _is_a (const char *type_id);
    virtual const char* _interface_repository_id (void) const;
    virtual ::CORBA::Boolean marshal (TAO_OutputCDR &cdr);
  
  protected:
    // Abstract or local interface only.
    Local2 (void);

    

    virtual ~Local2 (void);
  
  private:
    // Private and unimplemented for concrete interfaces.
    Local2 (const Local2 &);

    void operator= (const Local2 &);
  };

  // TAO_IDL - Generated from
  // be/be_visitor_sequence/sequence_ch.cpp:102

#if !defined (_SIMPLE_LOCAL2SEQ_CH_)
#define _SIMPLE_LOCAL2SEQ_CH_

  class Local2Seq;

  typedef
    ::TAO_VarSeq_Var_T<
        Local2Seq
      >
    Local2Seq_var;

  typedef
    ::TAO_Seq_Out_T<
        Local2Seq
      >
    Local2Seq_out;

  class  Local2Seq
    : public
        ::TAO::unbounded_object_reference_sequence<
            Local2,
            Local2_var
          >
  {
  public:
    Local2Seq (void);
    Local2Seq ( ::CORBA::ULong max);
    Local2Seq (
      ::CORBA::ULong max,
      ::CORBA::ULong length,
      Local2_ptr* buffer,
      ::CORBA::Boolean release = false);
    Local2Seq (const Local2Seq &);
    virtual ~Local2Seq (void);
    

    // TAO_IDL - Generated from
    // be/be_type.cpp:307

    
    typedef Local2Seq_var _var_type;
    typedef Local2Seq_out _out_type;
  };

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // be/be_type.cpp:261

  struct StructWithObjref;

  typedef
    ::TAO_Var_Var_T<
        StructWithObjref
      >
    StructWithObjref_var;

  typedef
    ::TAO_Out_T<
        StructWithObjref
      >
    StructWithObjref_out;

  // TAO_IDL - Generated from
  // be/be_visitor_structure/structure_ch.cpp:51

  struct  StructWithObjref
  {

    // TAO_IDL - Generated from
    // be/be_type.cpp:307

    
    typedef StructWithObjref_var _var_type;
    typedef StructWithObjref_out _out_type;
    
    simple::Local2_var objref;
    simple::Local2Seq objrefsequence;
  };

  // TAO_IDL - Generated from
  // be/be_interface.cpp:751

#if !defined (_SIMPLE_LOCAL3__VAR_OUT_CH_)
#define _SIMPLE_LOCAL3__VAR_OUT_CH_

  class Local3;
  typedef Local3 *Local3_ptr;

  typedef
    TAO_Objref_Var_T<
        Local3
      >
    Local3_var;
  
  typedef
    TAO_Objref_Out_T<
        Local3
      >
    Local3_out;

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // be/be_visitor_interface/interface_ch.cpp:43

  class  Local3
    : public virtual ::simple::Local2
  
  {
  public:

    // TAO_IDL - Generated from
    // be/be_type.cpp:307

    typedef Local3_ptr _ptr_type;
    typedef Local3_var _var_type;
    typedef Local3_out _out_type;

    // The static operations.
    static Local3_ptr _duplicate (Local3_ptr obj);

    static void _tao_release (Local3_ptr obj);

    static Local3_ptr _narrow (::CORBA::Object_ptr obj);
    static Local3_ptr _unchecked_narrow (::CORBA::Object_ptr obj);
    static Local3_ptr _nil (void);

    virtual ::simple::StructWithObjref * op3 (
      const ::simple::StructWithObjref & p1,
      ::simple::StructWithObjref & p2,
      ::simple::StructWithObjref_out p3) = 0;

    // TAO_IDL - Generated from
    // be/be_visitor_interface/interface_ch.cpp:140

    virtual ::CORBA::Boolean _is_a (const char *type_id);
    virtual const char* _interface_repository_id (void) const;
    virtual ::CORBA::Boolean marshal (TAO_OutputCDR &cdr);
  
  protected:
    // Abstract or local interface only.
    Local3 (void);

    

    virtual ~Local3 (void);
  
  private:
    // Private and unimplemented for concrete interfaces.
    Local3 (const Local3 &);

    void operator= (const Local3 &);
  };

// TAO_IDL - Generated from
// be/be_visitor_module/module_ch.cpp:67

} // module simple

// TAO_IDL - Generated from
// be/be_visitor_arg_traits.cpp:68

TAO_BEGIN_VERSIONED_NAMESPACE_DECL


// Arg traits specializations.
namespace TAO
{

  // TAO_IDL - Generated from
  // be/be_visitor_arg_traits.cpp:685

  template<>
  class Arg_Traits< ::simple::TestSeqTypedef>
    : public
        Var_Size_Arg_Traits_T<
            ::simple::TestSeqTypedef,
            TAO::Any_Insert_Policy_Noop
          >
  {
  };

  // TAO_IDL - Generated from
  // be/be_visitor_arg_traits.cpp:685

  template<>
  class Arg_Traits< ::simple::SeqOfTypedefedLong>
    : public
        Var_Size_Arg_Traits_T<
            ::simple::SeqOfTypedefedLong,
            TAO::Any_Insert_Policy_Noop
          >
  {
  };

  // TAO_IDL - Generated from
  // be/be_visitor_arg_traits.cpp:685

  template<>
  class Arg_Traits< ::simple::StringSeq>
    : public
        Var_Size_Arg_Traits_T<
            ::simple::StringSeq,
            TAO::Any_Insert_Policy_Noop
          >
  {
  };

  template<>
  class Arg_Traits< ::simple::TestArrayTypedef_tag>
    : public
        Fixed_Array_Arg_Traits_T<
            ::simple::TestArrayTypedef_var,
            ::simple::TestArrayTypedef_forany,
            TAO::Any_Insert_Policy_Noop
          >
  {
  };

  template<>
  class Arg_Traits< ::simple::TestStringArray_tag>
    : public
        Var_Array_Arg_Traits_T<
            ::simple::TestStringArray_out,
            ::simple::TestStringArray_forany,
            TAO::Any_Insert_Policy_Noop
          >
  {
  };

  // TAO_IDL - Generated from
  // be/be_visitor_arg_traits.cpp:685

  template<>
  class Arg_Traits< ::simple::StringSeqSeq>
    : public
        Var_Size_Arg_Traits_T<
            ::simple::StringSeqSeq,
            TAO::Any_Insert_Policy_Noop
          >
  {
  };

  // TAO_IDL - Generated from
  // be/be_visitor_arg_traits.cpp:685

  template<>
  class Arg_Traits< ::simple::StringSeqSeqSeq>
    : public
        Var_Size_Arg_Traits_T<
            ::simple::StringSeqSeqSeq,
            TAO::Any_Insert_Policy_Noop
          >
  {
  };

  // TAO_IDL - Generated from
  // be/be_visitor_arg_traits.cpp:685

  template<>
  class Arg_Traits< ::simple::LongSeqSeq>
    : public
        Var_Size_Arg_Traits_T<
            ::simple::LongSeqSeq,
            TAO::Any_Insert_Policy_Noop
          >
  {
  };

  // TAO_IDL - Generated from
  // be/be_visitor_arg_traits.cpp:685

  template<>
  class Arg_Traits< ::simple::LongSeqSeqSeq>
    : public
        Var_Size_Arg_Traits_T<
            ::simple::LongSeqSeqSeq,
            TAO::Any_Insert_Policy_Noop
          >
  {
  };

  // TAO_IDL - Generated from
  // be/be_visitor_arg_traits.cpp:947

  template<>
  class Arg_Traits< ::simple::TestStruct>
    : public
        Var_Size_Arg_Traits_T<
            ::simple::TestStruct,
            TAO::Any_Insert_Policy_Noop
          >
  {
  };

  // TAO_IDL - Generated from
  // be/be_visitor_arg_traits.cpp:685

  template<>
  class Arg_Traits< ::simple::TestStructSequence>
    : public
        Var_Size_Arg_Traits_T<
            ::simple::TestStructSequence,
            TAO::Any_Insert_Policy_Noop
          >
  {
  };

  template<>
  class Arg_Traits< ::simple::TestStructArray_tag>
    : public
        Var_Array_Arg_Traits_T<
            ::simple::TestStructArray_out,
            ::simple::TestStructArray_forany,
            TAO::Any_Insert_Policy_Noop
          >
  {
  };

  // TAO_IDL - Generated from
  // be/be_visitor_arg_traits.cpp:947

  template<>
  class Arg_Traits< ::simple::TestNestedStruct>
    : public
        Var_Size_Arg_Traits_T<
            ::simple::TestNestedStruct,
            TAO::Any_Insert_Policy_Noop
          >
  {
  };

  // TAO_IDL - Generated from
  // be/be_visitor_arg_traits.cpp:904

  template<>
  class Arg_Traits< ::simple::TestEnum>
    : public
        Basic_Arg_Traits_T<
            ::simple::TestEnum,
            TAO::Any_Insert_Policy_Noop
          >
  {
  };

  // TAO_IDL - Generated from
  // be/be_visitor_arg_traits.cpp:1058

  template<>
  class Arg_Traits< ::simple::TestUnion1>
    : public
        Fixed_Size_Arg_Traits_T<
            ::simple::TestUnion1,
            TAO::Any_Insert_Policy_Noop
          >
  {
  };

  // TAO_IDL - Generated from
  // be/be_visitor_arg_traits.cpp:1058

  template<>
  class Arg_Traits< ::simple::TestUnion2>
    : public
        Var_Size_Arg_Traits_T<
            ::simple::TestUnion2,
            TAO::Any_Insert_Policy_Noop
          >
  {
  };

  // TAO_IDL - Generated from
  // be/be_visitor_arg_traits.cpp:1058

  template<>
  class Arg_Traits< ::simple::TestUnion4>
    : public
        Fixed_Size_Arg_Traits_T<
            ::simple::TestUnion4,
            TAO::Any_Insert_Policy_Noop
          >
  {
  };

  // TAO_IDL - Generated from
  // be/be_visitor_arg_traits.cpp:685

  template<>
  class Arg_Traits< ::simple::EnumSeq>
    : public
        Var_Size_Arg_Traits_T<
            ::simple::EnumSeq,
            TAO::Any_Insert_Policy_Noop
          >
  {
  };

  template<>
  class Arg_Traits< ::simple::EnumArray_tag>
    : public
        Fixed_Array_Arg_Traits_T<
            ::simple::EnumArray_var,
            ::simple::EnumArray_forany,
            TAO::Any_Insert_Policy_Noop
          >
  {
  };

  // TAO_IDL - Generated from
  // be/be_visitor_arg_traits.cpp:947

  template<>
  class Arg_Traits< ::simple::TestStructWithEnum>
    : public
        Var_Size_Arg_Traits_T<
            ::simple::TestStructWithEnum,
            TAO::Any_Insert_Policy_Noop
          >
  {
  };

  // TAO_IDL - Generated from
  // be/be_visitor_arg_traits.cpp:147

#if !defined (_SIMPLE_TESTINTERF__ARG_TRAITS_)
#define _SIMPLE_TESTINTERF__ARG_TRAITS_

  template<>
  class  Arg_Traits< ::simple::TestInterf>
    : public
        Object_Arg_Traits_T<
            ::simple::TestInterf_ptr,
            ::simple::TestInterf_var,
            ::simple::TestInterf_out,
            TAO::Objref_Traits<simple::TestInterf>,
            TAO::Any_Insert_Policy_Noop
          >
  {
  };

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // be/be_visitor_arg_traits.cpp:685

  template<>
  class Arg_Traits< ::simple::TestUnion2Seq>
    : public
        Var_Size_Arg_Traits_T<
            ::simple::TestUnion2Seq,
            TAO::Any_Insert_Policy_Noop
          >
  {
  };

  // TAO_IDL - Generated from
  // be/be_visitor_arg_traits.cpp:1058

  template<>
  class Arg_Traits< ::simple::TestUnion3>
    : public
        Var_Size_Arg_Traits_T<
            ::simple::TestUnion3,
            TAO::Any_Insert_Policy_Noop
          >
  {
  };

  // TAO_IDL - Generated from
  // be/be_visitor_arg_traits.cpp:147

#if !defined (_SIMPLE_TESTINTERF2__ARG_TRAITS_)
#define _SIMPLE_TESTINTERF2__ARG_TRAITS_

  template<>
  class  Arg_Traits< ::simple::TestInterf2>
    : public
        Object_Arg_Traits_T<
            ::simple::TestInterf2_ptr,
            ::simple::TestInterf2_var,
            ::simple::TestInterf2_out,
            TAO::Objref_Traits<simple::TestInterf2>,
            TAO::Any_Insert_Policy_Noop
          >
  {
  };

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // be/be_visitor_arg_traits.cpp:147

#if !defined (_SIMPLE_TESTINTERF3__ARG_TRAITS_)
#define _SIMPLE_TESTINTERF3__ARG_TRAITS_

  template<>
  class  Arg_Traits< ::simple::TestInterf3>
    : public
        Object_Arg_Traits_T<
            ::simple::TestInterf3_ptr,
            ::simple::TestInterf3_var,
            ::simple::TestInterf3_out,
            TAO::Objref_Traits<simple::TestInterf3>,
            TAO::Any_Insert_Policy_Noop
          >
  {
  };

#endif /* end #if !defined */

  // TAO_IDL - Generated from
  // be/be_visitor_arg_traits.cpp:685

  template<>
  class Arg_Traits< ::simple::Local2Seq>
    : public
        Var_Size_Arg_Traits_T<
            ::simple::Local2Seq,
            TAO::Any_Insert_Policy_Noop
          >
  {
  };

  // TAO_IDL - Generated from
  // be/be_visitor_arg_traits.cpp:947

  template<>
  class Arg_Traits< ::simple::StructWithObjref>
    : public
        Var_Size_Arg_Traits_T<
            ::simple::StructWithObjref,
            TAO::Any_Insert_Policy_Noop
          >
  {
  };
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// be/be_visitor_traits.cpp:62

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

// Traits specializations.
namespace TAO
{
  template<>
  struct  Array_Traits<
      simple::TestArrayTypedef_forany
    >
  {
    static void free (
        simple::TestArrayTypedef_slice * _tao_slice);
    static simple::TestArrayTypedef_slice * dup (
        const simple::TestArrayTypedef_slice * _tao_slice);
    static void copy (
        simple::TestArrayTypedef_slice * _tao_to,
        const simple::TestArrayTypedef_slice * _tao_from);
    static simple::TestArrayTypedef_slice * alloc (void);
    static void zero (
        simple::TestArrayTypedef_slice * _tao_slice);
  };
  template<>
  struct  Array_Traits<
      simple::TestStringArray_forany
    >
  {
    static void free (
        simple::TestStringArray_slice * _tao_slice);
    static simple::TestStringArray_slice * dup (
        const simple::TestStringArray_slice * _tao_slice);
    static void copy (
        simple::TestStringArray_slice * _tao_to,
        const simple::TestStringArray_slice * _tao_from);
    static simple::TestStringArray_slice * alloc (void);
    static void zero (
        simple::TestStringArray_slice * _tao_slice);
  };
  template<>
  struct  Array_Traits<
      simple::TestStructArray_forany
    >
  {
    static void free (
        simple::TestStructArray_slice * _tao_slice);
    static simple::TestStructArray_slice * dup (
        const simple::TestStructArray_slice * _tao_slice);
    static void copy (
        simple::TestStructArray_slice * _tao_to,
        const simple::TestStructArray_slice * _tao_from);
    static simple::TestStructArray_slice * alloc (void);
    static void zero (
        simple::TestStructArray_slice * _tao_slice);
  };
  template<>
  struct  Array_Traits<
      simple::EnumArray_forany
    >
  {
    static void free (
        simple::EnumArray_slice * _tao_slice);
    static simple::EnumArray_slice * dup (
        const simple::EnumArray_slice * _tao_slice);
    static void copy (
        simple::EnumArray_slice * _tao_to,
        const simple::EnumArray_slice * _tao_from);
    static simple::EnumArray_slice * alloc (void);
    static void zero (
        simple::EnumArray_slice * _tao_slice);
  };

#if !defined (_SIMPLE_TESTINTERF__TRAITS_)
#define _SIMPLE_TESTINTERF__TRAITS_

  template<>
  struct  Objref_Traits< ::simple::TestInterf>
  {
    static ::simple::TestInterf_ptr duplicate (
        ::simple::TestInterf_ptr p);
    static void release (
        ::simple::TestInterf_ptr p);
    static ::simple::TestInterf_ptr nil (void);
    static ::CORBA::Boolean marshal (
        const ::simple::TestInterf_ptr p,
        TAO_OutputCDR & cdr);
  };

#endif /* end #if !defined */

#if !defined (_SIMPLE_TESTINTERF2__TRAITS_)
#define _SIMPLE_TESTINTERF2__TRAITS_

  template<>
  struct  Objref_Traits< ::simple::TestInterf2>
  {
    static ::simple::TestInterf2_ptr duplicate (
        ::simple::TestInterf2_ptr p);
    static void release (
        ::simple::TestInterf2_ptr p);
    static ::simple::TestInterf2_ptr nil (void);
    static ::CORBA::Boolean marshal (
        const ::simple::TestInterf2_ptr p,
        TAO_OutputCDR & cdr);
  };

#endif /* end #if !defined */

#if !defined (_SIMPLE_TESTINTERF3__TRAITS_)
#define _SIMPLE_TESTINTERF3__TRAITS_

  template<>
  struct  Objref_Traits< ::simple::TestInterf3>
  {
    static ::simple::TestInterf3_ptr duplicate (
        ::simple::TestInterf3_ptr p);
    static void release (
        ::simple::TestInterf3_ptr p);
    static ::simple::TestInterf3_ptr nil (void);
    static ::CORBA::Boolean marshal (
        const ::simple::TestInterf3_ptr p,
        TAO_OutputCDR & cdr);
  };

#endif /* end #if !defined */

#if !defined (_SIMPLE_TESTLI__TRAITS_)
#define _SIMPLE_TESTLI__TRAITS_

  template<>
  struct  Objref_Traits< ::simple::TestLI>
  {
    static ::simple::TestLI_ptr duplicate (
        ::simple::TestLI_ptr p);
    static void release (
        ::simple::TestLI_ptr p);
    static ::simple::TestLI_ptr nil (void);
    static ::CORBA::Boolean marshal (
        const ::simple::TestLI_ptr p,
        TAO_OutputCDR & cdr);
  };

#endif /* end #if !defined */

#if !defined (_SIMPLE_LOCAL2__TRAITS_)
#define _SIMPLE_LOCAL2__TRAITS_

  template<>
  struct  Objref_Traits< ::simple::Local2>
  {
    static ::simple::Local2_ptr duplicate (
        ::simple::Local2_ptr p);
    static void release (
        ::simple::Local2_ptr p);
    static ::simple::Local2_ptr nil (void);
    static ::CORBA::Boolean marshal (
        const ::simple::Local2_ptr p,
        TAO_OutputCDR & cdr);
  };

#endif /* end #if !defined */

#if !defined (_SIMPLE_LOCAL3__TRAITS_)
#define _SIMPLE_LOCAL3__TRAITS_

  template<>
  struct  Objref_Traits< ::simple::Local3>
  {
    static ::simple::Local3_ptr duplicate (
        ::simple::Local3_ptr p);
    static void release (
        ::simple::Local3_ptr p);
    static ::simple::Local3_ptr nil (void);
    static ::CORBA::Boolean marshal (
        const ::simple::Local3_ptr p,
        TAO_OutputCDR & cdr);
  };

#endif /* end #if !defined */
}
TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// be/be_visitor_sequence/cdr_op_ch.cpp:68

#if !defined _TAO_CDR_OP_simple_TestSeqTypedef_H_
#define _TAO_CDR_OP_simple_TestSeqTypedef_H_
TAO_BEGIN_VERSIONED_NAMESPACE_DECL


 ::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const simple::TestSeqTypedef &_tao_sequence);
 ::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    simple::TestSeqTypedef &_tao_sequence);

TAO_END_VERSIONED_NAMESPACE_DECL



#endif /* _TAO_CDR_OP_simple_TestSeqTypedef_H_ */

// TAO_IDL - Generated from
// be/be_visitor_sequence/cdr_op_ch.cpp:68

#if !defined _TAO_CDR_OP_simple_SeqOfTypedefedLong_H_
#define _TAO_CDR_OP_simple_SeqOfTypedefedLong_H_
TAO_BEGIN_VERSIONED_NAMESPACE_DECL


 ::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const simple::SeqOfTypedefedLong &_tao_sequence);
 ::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    simple::SeqOfTypedefedLong &_tao_sequence);

TAO_END_VERSIONED_NAMESPACE_DECL



#endif /* _TAO_CDR_OP_simple_SeqOfTypedefedLong_H_ */

// TAO_IDL - Generated from
// be/be_visitor_sequence/cdr_op_ch.cpp:68

#if !defined _TAO_CDR_OP_simple_StringSeq_H_
#define _TAO_CDR_OP_simple_StringSeq_H_
TAO_BEGIN_VERSIONED_NAMESPACE_DECL


 ::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const simple::StringSeq &_tao_sequence);
 ::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    simple::StringSeq &_tao_sequence);

TAO_END_VERSIONED_NAMESPACE_DECL



#endif /* _TAO_CDR_OP_simple_StringSeq_H_ */

// TAO_IDL - Generated from
// be/be_visitor_array/cdr_op_ch.cpp:102


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

 CORBA::Boolean operator<< (TAO_OutputCDR &strm, const simple::TestArrayTypedef_forany &_tao_array);
 ::CORBA::Boolean operator>> (TAO_InputCDR &, simple::TestArrayTypedef_forany &_tao_array);

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// be/be_visitor_array/cdr_op_ch.cpp:102


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

 CORBA::Boolean operator<< (TAO_OutputCDR &strm, const simple::TestStringArray_forany &_tao_array);
 ::CORBA::Boolean operator>> (TAO_InputCDR &, simple::TestStringArray_forany &_tao_array);

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// be/be_visitor_sequence/cdr_op_ch.cpp:68

#if !defined _TAO_CDR_OP_simple_StringSeqSeq_H_
#define _TAO_CDR_OP_simple_StringSeqSeq_H_
TAO_BEGIN_VERSIONED_NAMESPACE_DECL


 ::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const simple::StringSeqSeq &_tao_sequence);
 ::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    simple::StringSeqSeq &_tao_sequence);

TAO_END_VERSIONED_NAMESPACE_DECL



#endif /* _TAO_CDR_OP_simple_StringSeqSeq_H_ */

// TAO_IDL - Generated from
// be/be_visitor_sequence/cdr_op_ch.cpp:68

#if !defined _TAO_CDR_OP_simple_StringSeqSeqSeq_H_
#define _TAO_CDR_OP_simple_StringSeqSeqSeq_H_
TAO_BEGIN_VERSIONED_NAMESPACE_DECL


 ::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const simple::StringSeqSeqSeq &_tao_sequence);
 ::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    simple::StringSeqSeqSeq &_tao_sequence);

TAO_END_VERSIONED_NAMESPACE_DECL



#endif /* _TAO_CDR_OP_simple_StringSeqSeqSeq_H_ */

// TAO_IDL - Generated from
// be/be_visitor_sequence/cdr_op_ch.cpp:68

#if !defined _TAO_CDR_OP_simple_LongSeqSeq_H_
#define _TAO_CDR_OP_simple_LongSeqSeq_H_
TAO_BEGIN_VERSIONED_NAMESPACE_DECL


 ::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const simple::LongSeqSeq &_tao_sequence);
 ::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    simple::LongSeqSeq &_tao_sequence);

TAO_END_VERSIONED_NAMESPACE_DECL



#endif /* _TAO_CDR_OP_simple_LongSeqSeq_H_ */

// TAO_IDL - Generated from
// be/be_visitor_sequence/cdr_op_ch.cpp:68

#if !defined _TAO_CDR_OP_simple_LongSeqSeqSeq_H_
#define _TAO_CDR_OP_simple_LongSeqSeqSeq_H_
TAO_BEGIN_VERSIONED_NAMESPACE_DECL


 ::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const simple::LongSeqSeqSeq &_tao_sequence);
 ::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    simple::LongSeqSeqSeq &_tao_sequence);

TAO_END_VERSIONED_NAMESPACE_DECL



#endif /* _TAO_CDR_OP_simple_LongSeqSeqSeq_H_ */

// TAO_IDL - Generated from
// be/be_visitor_structure/cdr_op_ch.cpp:46


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

 ::CORBA::Boolean operator<< (TAO_OutputCDR &, const simple::TestStruct &);
 ::CORBA::Boolean operator>> (TAO_InputCDR &, simple::TestStruct &);

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// be/be_visitor_sequence/cdr_op_ch.cpp:68

#if !defined _TAO_CDR_OP_simple_TestStructSequence_H_
#define _TAO_CDR_OP_simple_TestStructSequence_H_
TAO_BEGIN_VERSIONED_NAMESPACE_DECL


 ::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const simple::TestStructSequence &_tao_sequence);
 ::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    simple::TestStructSequence &_tao_sequence);

TAO_END_VERSIONED_NAMESPACE_DECL



#endif /* _TAO_CDR_OP_simple_TestStructSequence_H_ */

// TAO_IDL - Generated from
// be/be_visitor_array/cdr_op_ch.cpp:102


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

 CORBA::Boolean operator<< (TAO_OutputCDR &strm, const simple::TestStructArray_forany &_tao_array);
 ::CORBA::Boolean operator>> (TAO_InputCDR &, simple::TestStructArray_forany &_tao_array);

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// be/be_visitor_structure/cdr_op_ch.cpp:46


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

 ::CORBA::Boolean operator<< (TAO_OutputCDR &, const simple::TestNestedStruct &);
 ::CORBA::Boolean operator>> (TAO_InputCDR &, simple::TestNestedStruct &);

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// be/be_visitor_enum/cdr_op_ch.cpp:37


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

 ::CORBA::Boolean operator<< (TAO_OutputCDR &strm, simple::TestEnum _tao_enumerator);
 ::CORBA::Boolean operator>> (TAO_InputCDR &strm, simple::TestEnum &_tao_enumerator);

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// be/be_visitor_union/cdr_op_ch.cpp:41


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

 ::CORBA::Boolean operator<< (TAO_OutputCDR &, const simple::TestUnion1 &);
 ::CORBA::Boolean operator>> (TAO_InputCDR &, simple::TestUnion1 &);

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// be/be_visitor_union/cdr_op_ch.cpp:41


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

 ::CORBA::Boolean operator<< (TAO_OutputCDR &, const simple::TestUnion2 &);
 ::CORBA::Boolean operator>> (TAO_InputCDR &, simple::TestUnion2 &);

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// be/be_visitor_union/cdr_op_ch.cpp:41


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

 ::CORBA::Boolean operator<< (TAO_OutputCDR &, const simple::TestUnion4 &);
 ::CORBA::Boolean operator>> (TAO_InputCDR &, simple::TestUnion4 &);

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// be/be_visitor_sequence/cdr_op_ch.cpp:68

#if !defined _TAO_CDR_OP_simple_EnumSeq_H_
#define _TAO_CDR_OP_simple_EnumSeq_H_
TAO_BEGIN_VERSIONED_NAMESPACE_DECL


 ::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const simple::EnumSeq &_tao_sequence);
 ::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    simple::EnumSeq &_tao_sequence);

TAO_END_VERSIONED_NAMESPACE_DECL



#endif /* _TAO_CDR_OP_simple_EnumSeq_H_ */

// TAO_IDL - Generated from
// be/be_visitor_array/cdr_op_ch.cpp:102


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

 CORBA::Boolean operator<< (TAO_OutputCDR &strm, const simple::EnumArray_forany &_tao_array);
 ::CORBA::Boolean operator>> (TAO_InputCDR &, simple::EnumArray_forany &_tao_array);

TAO_END_VERSIONED_NAMESPACE_DECL


// TAO_IDL - Generated from
// be/be_visitor_structure/cdr_op_ch.cpp:46


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

 ::CORBA::Boolean operator<< (TAO_OutputCDR &, const simple::TestStructWithEnum &);
 ::CORBA::Boolean operator>> (TAO_InputCDR &, simple::TestStructWithEnum &);

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// be/be_visitor_interface/cdr_op_ch.cpp:44

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

 ::CORBA::Boolean operator<< (TAO_OutputCDR &, const simple::TestInterf_ptr );
 ::CORBA::Boolean operator>> (TAO_InputCDR &, simple::TestInterf_ptr &);

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// be/be_visitor_sequence/cdr_op_ch.cpp:68

#if !defined _TAO_CDR_OP_simple_TestUnion2Seq_H_
#define _TAO_CDR_OP_simple_TestUnion2Seq_H_
TAO_BEGIN_VERSIONED_NAMESPACE_DECL


 ::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const simple::TestUnion2Seq &_tao_sequence);
 ::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    simple::TestUnion2Seq &_tao_sequence);

TAO_END_VERSIONED_NAMESPACE_DECL



#endif /* _TAO_CDR_OP_simple_TestUnion2Seq_H_ */

// TAO_IDL - Generated from
// be/be_visitor_union/cdr_op_ch.cpp:41


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

 ::CORBA::Boolean operator<< (TAO_OutputCDR &, const simple::TestUnion3 &);
 ::CORBA::Boolean operator>> (TAO_InputCDR &, simple::TestUnion3 &);

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// be/be_visitor_interface/cdr_op_ch.cpp:44

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

 ::CORBA::Boolean operator<< (TAO_OutputCDR &, const simple::TestInterf2_ptr );
 ::CORBA::Boolean operator>> (TAO_InputCDR &, simple::TestInterf2_ptr &);

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// be/be_visitor_interface/cdr_op_ch.cpp:44

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

 ::CORBA::Boolean operator<< (TAO_OutputCDR &, const simple::TestInterf3_ptr );
 ::CORBA::Boolean operator>> (TAO_InputCDR &, simple::TestInterf3_ptr &);

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// be/be_codegen.cpp:1703
#if defined (__ACE_INLINE__)
#include "simpleC.inl"
#endif /* defined INLINE */

#include /**/ "ace/post.h"

#endif /* ifndef */


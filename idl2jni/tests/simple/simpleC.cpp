// -*- C++ -*-
// $Id$

/**
 * Code generated by the The ACE ORB (TAO) IDL Compiler v2.2a_p9
 * TAO and the TAO IDL Compiler have been developed by:
 *       Center for Distributed Object Computing
 *       Washington University
 *       St. Louis, MO
 *       USA
 *       http://www.cs.wustl.edu/~schmidt/doc-center.html
 * and
 *       Distributed Object Computing Laboratory
 *       University of California at Irvine
 *       Irvine, CA
 *       USA
 * and
 *       Institute for Software Integrated Systems
 *       Vanderbilt University
 *       Nashville, TN
 *       USA
 *       http://www.isis.vanderbilt.edu/
 *
 * Information about TAO is available at:
 *     http://www.cs.wustl.edu/~schmidt/TAO.html
 **/

// TAO_IDL - Generated from
// be/be_codegen.cpp:376


#include "simpleC.h"
#include "tao/CDR.h"
#include "tao/Exception_Data.h"
#include "tao/Invocation_Adapter.h"
#include "tao/Object_T.h"
#include "ace/OS_NS_string.h"

#if !defined (__ACE_INLINE__)
#include "simpleC.inl"
#endif /* !defined INLINE */

// TAO_IDL - Generated from
// be/be_visitor_sequence/sequence_cs.cpp:73

#if !defined (_SIMPLE_TESTSEQTYPEDEF_CS_)
#define _SIMPLE_TESTSEQTYPEDEF_CS_

simple::TestSeqTypedef::TestSeqTypedef (void)
{}

simple::TestSeqTypedef::TestSeqTypedef (
    ::CORBA::ULong max)
  : ::TAO::unbounded_value_sequence<
        ::CORBA::Long
      > (max)
{}

simple::TestSeqTypedef::TestSeqTypedef (
    ::CORBA::ULong max,
    ::CORBA::ULong length,
    ::CORBA::Long * buffer,
    ::CORBA::Boolean release
  )
  : ::TAO::unbounded_value_sequence<
        ::CORBA::Long
      >
    (max, length, buffer, release)
{}

simple::TestSeqTypedef::TestSeqTypedef (
    const TestSeqTypedef &seq)
  : ::TAO::unbounded_value_sequence<
        ::CORBA::Long
      > (seq)
{}

simple::TestSeqTypedef::~TestSeqTypedef (void)
{}

#endif /* end #if !defined */

// TAO_IDL - Generated from
// be/be_visitor_sequence/sequence_cs.cpp:73

#if !defined (_SIMPLE_SEQOFTYPEDEFEDLONG_CS_)
#define _SIMPLE_SEQOFTYPEDEFEDLONG_CS_

simple::SeqOfTypedefedLong::SeqOfTypedefedLong (void)
{}

simple::SeqOfTypedefedLong::SeqOfTypedefedLong (
    ::CORBA::ULong max)
  : ::TAO::unbounded_value_sequence<
        TestTypedef
      > (max)
{}

simple::SeqOfTypedefedLong::SeqOfTypedefedLong (
    ::CORBA::ULong max,
    ::CORBA::ULong length,
    ::CORBA::Long * buffer,
    ::CORBA::Boolean release
  )
  : ::TAO::unbounded_value_sequence<
        TestTypedef
      >
    (max, length, buffer, release)
{}

simple::SeqOfTypedefedLong::SeqOfTypedefedLong (
    const SeqOfTypedefedLong &seq)
  : ::TAO::unbounded_value_sequence<
        TestTypedef
      > (seq)
{}

simple::SeqOfTypedefedLong::~SeqOfTypedefedLong (void)
{}

#endif /* end #if !defined */

// TAO_IDL - Generated from
// be/be_visitor_sequence/sequence_cs.cpp:73

#if !defined (_SIMPLE_STRINGSEQ_CS_)
#define _SIMPLE_STRINGSEQ_CS_

simple::StringSeq::StringSeq (void)
{}

simple::StringSeq::StringSeq (
    ::CORBA::ULong max)
  : ::TAO::unbounded_basic_string_sequence<char> (max)
{}

simple::StringSeq::StringSeq (
    ::CORBA::ULong max,
    ::CORBA::ULong length,
    ::CORBA::Char * * buffer,
    ::CORBA::Boolean release
  )
  : ::TAO::unbounded_basic_string_sequence<char>
    (max, length, buffer, release)
{}

simple::StringSeq::StringSeq (
    const StringSeq &seq)
  : ::TAO::unbounded_basic_string_sequence<char> (seq)
{}

simple::StringSeq::~StringSeq (void)
{}

#endif /* end #if !defined */

// TAO_IDL - Generated from
// be/be_visitor_array/array_cs.cpp:97

simple::TestArrayTypedef_slice *
simple::TestArrayTypedef_dup (const simple::TestArrayTypedef_slice *_tao_src_array)
{
  simple::TestArrayTypedef_slice *_tao_dup_array =
    simple::TestArrayTypedef_alloc ();
  
  if (!_tao_dup_array)
    {
      return static_cast <simple::TestArrayTypedef_slice *> (0);
    }
  
  simple::TestArrayTypedef_copy (_tao_dup_array, _tao_src_array);
  return _tao_dup_array;
}

simple::TestArrayTypedef_slice *
simple::TestArrayTypedef_alloc (void)
{
  simple::TestArrayTypedef_slice *retval = 0;
  ACE_NEW_RETURN (retval, ::CORBA::Long[4], 0);
  return retval;
}

void
simple::TestArrayTypedef_free (
    simple::TestArrayTypedef_slice *_tao_slice)
{
  delete [] _tao_slice;
}

void
simple::TestArrayTypedef_copy (
    simple::TestArrayTypedef_slice * _tao_to,
    const simple::TestArrayTypedef_slice *_tao_from)
{
  // Copy each individual element.
  for ( ::CORBA::ULong i0 = 0; i0 < 4; ++i0)
    {
      _tao_to[i0] = _tao_from[i0];
    }
}

// TAO_IDL - Generated from
// be/be_visitor_array/array_cs.cpp:97

simple::TestStringArray_slice *
simple::TestStringArray_dup (const simple::TestStringArray_slice *_tao_src_array)
{
  simple::TestStringArray_slice *_tao_dup_array =
    simple::TestStringArray_alloc ();
  
  if (!_tao_dup_array)
    {
      return static_cast <simple::TestStringArray_slice *> (0);
    }
  
  simple::TestStringArray_copy (_tao_dup_array, _tao_src_array);
  return _tao_dup_array;
}

simple::TestStringArray_slice *
simple::TestStringArray_alloc (void)
{
  simple::TestStringArray_slice *retval = 0;
  ACE_NEW_RETURN (retval, ::TAO::String_Manager[4], 0);
  return retval;
}

void
simple::TestStringArray_free (
    simple::TestStringArray_slice *_tao_slice)
{
  delete [] _tao_slice;
}

void
simple::TestStringArray_copy (
    simple::TestStringArray_slice * _tao_to,
    const simple::TestStringArray_slice *_tao_from)
{
  // Copy each individual element.
  for ( ::CORBA::ULong i0 = 0; i0 < 4; ++i0)
    {
      _tao_to[i0] = _tao_from[i0];
    }
}

// TAO_IDL - Generated from
// be/be_visitor_sequence/sequence_cs.cpp:73

#if !defined (_SIMPLE_STRINGSEQSEQ_CS_)
#define _SIMPLE_STRINGSEQSEQ_CS_

simple::StringSeqSeq::StringSeqSeq (void)
{}

simple::StringSeqSeq::StringSeqSeq (
    ::CORBA::ULong max)
  : ::TAO::unbounded_value_sequence<
        StringSeq
      > (max)
{}

simple::StringSeqSeq::StringSeqSeq (
    ::CORBA::ULong max,
    ::CORBA::ULong length,
    simple::StringSeq * buffer,
    ::CORBA::Boolean release
  )
  : ::TAO::unbounded_value_sequence<
        StringSeq
      >
    (max, length, buffer, release)
{}

simple::StringSeqSeq::StringSeqSeq (
    const StringSeqSeq &seq)
  : ::TAO::unbounded_value_sequence<
        StringSeq
      > (seq)
{}

simple::StringSeqSeq::~StringSeqSeq (void)
{}

#endif /* end #if !defined */

// TAO_IDL - Generated from
// be/be_visitor_sequence/sequence_cs.cpp:73

#if !defined (_SIMPLE_STRINGSEQSEQSEQ_CS_)
#define _SIMPLE_STRINGSEQSEQSEQ_CS_

simple::StringSeqSeqSeq::StringSeqSeqSeq (void)
{}

simple::StringSeqSeqSeq::StringSeqSeqSeq (
    ::CORBA::ULong max)
  : ::TAO::unbounded_value_sequence<
        StringSeqSeq
      > (max)
{}

simple::StringSeqSeqSeq::StringSeqSeqSeq (
    ::CORBA::ULong max,
    ::CORBA::ULong length,
    simple::StringSeqSeq * buffer,
    ::CORBA::Boolean release
  )
  : ::TAO::unbounded_value_sequence<
        StringSeqSeq
      >
    (max, length, buffer, release)
{}

simple::StringSeqSeqSeq::StringSeqSeqSeq (
    const StringSeqSeqSeq &seq)
  : ::TAO::unbounded_value_sequence<
        StringSeqSeq
      > (seq)
{}

simple::StringSeqSeqSeq::~StringSeqSeqSeq (void)
{}

#endif /* end #if !defined */

// TAO_IDL - Generated from
// be/be_visitor_sequence/sequence_cs.cpp:73

#if !defined (_SIMPLE_LONGSEQSEQ_CS_)
#define _SIMPLE_LONGSEQSEQ_CS_

simple::LongSeqSeq::LongSeqSeq (void)
{}

simple::LongSeqSeq::LongSeqSeq (
    ::CORBA::ULong max)
  : ::TAO::unbounded_value_sequence<
        TestSeqTypedef
      > (max)
{}

simple::LongSeqSeq::LongSeqSeq (
    ::CORBA::ULong max,
    ::CORBA::ULong length,
    simple::TestSeqTypedef * buffer,
    ::CORBA::Boolean release
  )
  : ::TAO::unbounded_value_sequence<
        TestSeqTypedef
      >
    (max, length, buffer, release)
{}

simple::LongSeqSeq::LongSeqSeq (
    const LongSeqSeq &seq)
  : ::TAO::unbounded_value_sequence<
        TestSeqTypedef
      > (seq)
{}

simple::LongSeqSeq::~LongSeqSeq (void)
{}

#endif /* end #if !defined */

// TAO_IDL - Generated from
// be/be_visitor_sequence/sequence_cs.cpp:73

#if !defined (_SIMPLE_LONGSEQSEQSEQ_CS_)
#define _SIMPLE_LONGSEQSEQSEQ_CS_

simple::LongSeqSeqSeq::LongSeqSeqSeq (void)
{}

simple::LongSeqSeqSeq::LongSeqSeqSeq (
    ::CORBA::ULong max)
  : ::TAO::unbounded_value_sequence<
        LongSeqSeq
      > (max)
{}

simple::LongSeqSeqSeq::LongSeqSeqSeq (
    ::CORBA::ULong max,
    ::CORBA::ULong length,
    simple::LongSeqSeq * buffer,
    ::CORBA::Boolean release
  )
  : ::TAO::unbounded_value_sequence<
        LongSeqSeq
      >
    (max, length, buffer, release)
{}

simple::LongSeqSeqSeq::LongSeqSeqSeq (
    const LongSeqSeqSeq &seq)
  : ::TAO::unbounded_value_sequence<
        LongSeqSeq
      > (seq)
{}

simple::LongSeqSeqSeq::~LongSeqSeqSeq (void)
{}

#endif /* end #if !defined */

// TAO_IDL - Generated from
// be/be_visitor_sequence/sequence_cs.cpp:73

#if !defined (_SIMPLE_TESTSTRUCTSEQUENCE_CS_)
#define _SIMPLE_TESTSTRUCTSEQUENCE_CS_

simple::TestStructSequence::TestStructSequence (void)
{}

simple::TestStructSequence::TestStructSequence (
    ::CORBA::ULong max)
  : ::TAO::unbounded_value_sequence<
        TestStruct
      > (max)
{}

simple::TestStructSequence::TestStructSequence (
    ::CORBA::ULong max,
    ::CORBA::ULong length,
    simple::TestStruct * buffer,
    ::CORBA::Boolean release
  )
  : ::TAO::unbounded_value_sequence<
        TestStruct
      >
    (max, length, buffer, release)
{}

simple::TestStructSequence::TestStructSequence (
    const TestStructSequence &seq)
  : ::TAO::unbounded_value_sequence<
        TestStruct
      > (seq)
{}

simple::TestStructSequence::~TestStructSequence (void)
{}

#endif /* end #if !defined */

// TAO_IDL - Generated from
// be/be_visitor_array/array_cs.cpp:97

simple::TestStructArray_slice *
simple::TestStructArray_dup (const simple::TestStructArray_slice *_tao_src_array)
{
  simple::TestStructArray_slice *_tao_dup_array =
    simple::TestStructArray_alloc ();
  
  if (!_tao_dup_array)
    {
      return static_cast <simple::TestStructArray_slice *> (0);
    }
  
  simple::TestStructArray_copy (_tao_dup_array, _tao_src_array);
  return _tao_dup_array;
}

simple::TestStructArray_slice *
simple::TestStructArray_alloc (void)
{
  simple::TestStructArray_slice *retval = 0;
  ACE_NEW_RETURN (retval, simple::TestStruct[4], 0);
  return retval;
}

void
simple::TestStructArray_free (
    simple::TestStructArray_slice *_tao_slice)
{
  delete [] _tao_slice;
}

void
simple::TestStructArray_copy (
    simple::TestStructArray_slice * _tao_to,
    const simple::TestStructArray_slice *_tao_from)
{
  // Copy each individual element.
  for ( ::CORBA::ULong i0 = 0; i0 < 4; ++i0)
    {
      _tao_to[i0] = _tao_from[i0];
    }
}

// TAO_IDL - Generated from
// be/be_visitor_union/union_cs.cpp:79

simple::TestUnion1::TestUnion1 (void)
{
  ACE_OS::memset (&this->u_, 0, sizeof (this->u_));
  this->disc_ = (simple::TestEnum) -1;
}

simple::TestUnion1::TestUnion1 (const ::simple::TestUnion1 &u)
{
  this->disc_ = u.disc_;
  switch (this->disc_)
  {
    case simple::a:
    {
      this->u_.o_ = u.u_.o_;
    }
    break;
    case simple::b:
    {
      this->u_.s_ = u.u_.s_;
    }
    break;
    case simple::c:
    {
      this->u_.l_ = u.u_.l_;
    }
    break;
    case simple::d:
    {
      this->u_.n_ = u.u_.n_;
    }
    break;
    case simple::e:
    {
      this->u_.u_ = u.u_.u_;
    }
    break;
    default:
    break;
  }
}

simple::TestUnion1::~TestUnion1 (void)
{
  // Finalize.
  this->_reset ();
}

simple::TestUnion1 &
simple::TestUnion1::operator= (const ::simple::TestUnion1 &u)
{
  if (&u == this)
    {
      return *this;
    }
  
  this->_reset ();
  this->disc_ = u.disc_;

  switch (this->disc_)
  {
    case simple::a:
    {
      this->u_.o_ = u.u_.o_;
    }
    break;
    case simple::b:
    {
      this->u_.s_ = u.u_.s_;
    }
    break;
    case simple::c:
    {
      this->u_.l_ = u.u_.l_;
    }
    break;
    case simple::d:
    {
      this->u_.n_ = u.u_.n_;
    }
    break;
    case simple::e:
    {
      this->u_.u_ = u.u_.u_;
    }
    break;
    default:
    break;
  }
  
  return *this;
}

/// Reset method to reset old values of a union.
void simple::TestUnion1::_reset (void)
{
  switch (this->disc_)
  {
    
    case simple::a:
      
    break;
    
    case simple::b:
      
    break;
    
    case simple::c:
      
    break;
    
    case simple::d:
      
    break;
    
    case simple::e:
      
    break;
    
    default:
    break;
  }
}

// TAO_IDL - Generated from
// be/be_visitor_union/union_cs.cpp:79

simple::TestUnion2::TestUnion2 (void)
{
  ACE_OS::memset (&this->u_, 0, sizeof (this->u_));
  this->disc_ = -32768;
}

simple::TestUnion2::TestUnion2 (const ::simple::TestUnion2 &u)
{
  this->disc_ = u.disc_;
  switch (this->disc_)
  {
    case 0:
    {
      this->u_.s_ = ::CORBA::string_dup (u.u_.s_);
    }
    break;
    case 1:
    {
      if (u.u_.t_ == 0)
        {
          this->u_.t_ = 0;
        }
      else
        {
          ACE_NEW (
              this->u_.t_,
              simple::TestStruct (*u.u_.t_)
            );
        }
    }
    break;
    case 2:
    case 3:
    {
      if (u.u_.q_ == 0)
        {
          this->u_.q_ = 0;
        }
      else
        {
          ACE_NEW (
              this->u_.q_,
              simple::TestSeqTypedef (*u.u_.q_)
            );
        }
    }
    break;
    case 4:
    {
      this->u_.d_ = ::CORBA::string_dup (u.u_.d_);
    }
    break;
    default:
    {
      this->u_.e_ = 
        u.u_.e_;
    }
    break;
  }
}

simple::TestUnion2::~TestUnion2 (void)
{
  // Finalize.
  this->_reset ();
}

simple::TestUnion2 &
simple::TestUnion2::operator= (const ::simple::TestUnion2 &u)
{
  if (&u == this)
    {
      return *this;
    }
  
  this->_reset ();
  this->disc_ = u.disc_;

  switch (this->disc_)
  {
    case 0:
    {
      this->u_.s_ = ::CORBA::string_dup (u.u_.s_);
    }
    break;
    case 1:
    {
      if (u.u_.t_ == 0)
        {
          this->u_.t_ = 0;
        }
      else
        {
          ACE_NEW_RETURN (
              this->u_.t_,
              simple::TestStruct (*u.u_.t_),
              *this
            );
        }
    }
    break;
    case 2:
    case 3:
    {
      if (u.u_.q_ == 0)
        {
          this->u_.q_ = 0;
        }
      else
        {
          ACE_NEW_RETURN (
              this->u_.q_,
              simple::TestSeqTypedef (*u.u_.q_),
              *this
            );
        }
    }
    break;
    case 4:
    {
      this->u_.d_ = ::CORBA::string_dup (u.u_.d_);
    }
    break;
    default:
    {
      this->u_.e_ = 
        u.u_.e_;
    }
    break;
  }
  
  return *this;
}

/// Reset method to reset old values of a union.
void simple::TestUnion2::_reset (void)
{
  switch (this->disc_)
  {
    
    case 0:
      ::CORBA::string_free (this->u_.s_);
      this->u_.s_ = 0;
      
    break;
    
    case 1:
      delete this->u_.t_;
      this->u_.t_ = 0;
      
    break;
    
    case 2:
    case 3:
      delete this->u_.q_;
      this->u_.q_ = 0;
      
    break;
    
    case 4:
      ::CORBA::string_free (this->u_.d_);
      this->u_.d_ = 0;
      
    break;
    
    default:
      
    break;
    
  }
}

// TAO_IDL - Generated from
// be/be_visitor_union/union_cs.cpp:79

simple::TestUnion4::TestUnion4 (void)
{
  ACE_OS::memset (&this->u_, 0, sizeof (this->u_));
  this->disc_ = false;
}

simple::TestUnion4::TestUnion4 (const ::simple::TestUnion4 &u)
{
  this->disc_ = u.disc_;
  
  if (this->disc_)
    {
      this->u_.c_ = u.u_.c_;
    }
  
}

simple::TestUnion4::~TestUnion4 (void)
{
  // Finalize.
  this->_reset ();
}

simple::TestUnion4 &
simple::TestUnion4::operator= (const ::simple::TestUnion4 &u)
{
  if (&u == this)
    {
      return *this;
    }
  
  this->_reset ();
  this->disc_ = u.disc_;

  
  if (this->disc_)
    {
      this->u_.c_ = u.u_.c_;
    }
  
  return *this;
}

/// Reset method to reset old values of a union.
void simple::TestUnion4::_reset (void)
{
  
  if (this->disc_)
    {
      
    }
  
}

// TAO_IDL - Generated from
// be/be_visitor_sequence/sequence_cs.cpp:73

#if !defined (_SIMPLE_ENUMSEQ_CS_)
#define _SIMPLE_ENUMSEQ_CS_

simple::EnumSeq::EnumSeq (void)
{}

simple::EnumSeq::EnumSeq (
    ::CORBA::ULong max)
  : ::TAO::unbounded_value_sequence<
        TestEnum
      > (max)
{}

simple::EnumSeq::EnumSeq (
    ::CORBA::ULong max,
    ::CORBA::ULong length,
    simple::TestEnum * buffer,
    ::CORBA::Boolean release
  )
  : ::TAO::unbounded_value_sequence<
        TestEnum
      >
    (max, length, buffer, release)
{}

simple::EnumSeq::EnumSeq (
    const EnumSeq &seq)
  : ::TAO::unbounded_value_sequence<
        TestEnum
      > (seq)
{}

simple::EnumSeq::~EnumSeq (void)
{}

#endif /* end #if !defined */

// TAO_IDL - Generated from
// be/be_visitor_array/array_cs.cpp:97

simple::EnumArray_slice *
simple::EnumArray_dup (const simple::EnumArray_slice *_tao_src_array)
{
  simple::EnumArray_slice *_tao_dup_array =
    simple::EnumArray_alloc ();
  
  if (!_tao_dup_array)
    {
      return static_cast <simple::EnumArray_slice *> (0);
    }
  
  simple::EnumArray_copy (_tao_dup_array, _tao_src_array);
  return _tao_dup_array;
}

simple::EnumArray_slice *
simple::EnumArray_alloc (void)
{
  simple::EnumArray_slice *retval = 0;
  ACE_NEW_RETURN (retval, simple::TestEnum[4], 0);
  return retval;
}

void
simple::EnumArray_free (
    simple::EnumArray_slice *_tao_slice)
{
  delete [] _tao_slice;
}

void
simple::EnumArray_copy (
    simple::EnumArray_slice * _tao_to,
    const simple::EnumArray_slice *_tao_from)
{
  // Copy each individual element.
  for ( ::CORBA::ULong i0 = 0; i0 < 4; ++i0)
    {
      _tao_to[i0] = _tao_from[i0];
    }
}

// TAO_IDL - Generated from
// be/be_visitor_interface/interface_cs.cpp:51

// Traits specializations for simple::TestInterf.

simple::TestInterf_ptr
TAO::Objref_Traits<simple::TestInterf>::duplicate (
    simple::TestInterf_ptr p)
{
  return simple::TestInterf::_duplicate (p);
}

void
TAO::Objref_Traits<simple::TestInterf>::release (
    simple::TestInterf_ptr p)
{
  ::CORBA::release (p);
}

simple::TestInterf_ptr
TAO::Objref_Traits<simple::TestInterf>::nil (void)
{
  return simple::TestInterf::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<simple::TestInterf>::marshal (
    const simple::TestInterf_ptr p,
    TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

// TAO_IDL - Generated from
// be/be_visitor_operation/operation_cs.cpp:91

::simple::TestArrayTypedef_slice *
simple::TestInterf::op1 (
  ::simple::TestEnum p1,
  ::CORBA::UShort & p2,
  ::simple::TestSeqTypedef_out p3,
  ::CORBA::String_out p4)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  TAO::Arg_Traits< ::simple::TestArrayTypedef_tag>::ret_val _tao_retval;
  TAO::Arg_Traits< ::simple::TestEnum>::in_arg_val _tao_p1 (p1);
  TAO::Arg_Traits< ::CORBA::UShort>::inout_arg_val _tao_p2 (p2);
  TAO::Arg_Traits< ::simple::TestSeqTypedef>::out_arg_val _tao_p3 (p3);
  TAO::Arg_Traits< char *>::out_arg_val _tao_p4 (p4);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_p1,
      &_tao_p2,
      &_tao_p3,
      &_tao_p4
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      5,
      "op1",
      3,
      TAO::TAO_CO_NONE | TAO::TAO_CO_THRU_POA_STRATEGY
      
    );

  _tao_call.invoke (0, 0);

  return _tao_retval.retn ();
}

// TAO_IDL - Generated from
// be/be_visitor_operation/operation_cs.cpp:91

::simple::TestUnion4
simple::TestInterf::opu (
  const ::simple::TestUnion1 & p1,
  ::simple::TestUnion2 & p2,
  ::simple::TestUnion1_out p4)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  TAO::Arg_Traits< ::simple::TestUnion4>::ret_val _tao_retval;
  TAO::Arg_Traits< ::simple::TestUnion1>::in_arg_val _tao_p1 (p1);
  TAO::Arg_Traits< ::simple::TestUnion2>::inout_arg_val _tao_p2 (p2);
  TAO::Arg_Traits< ::simple::TestUnion1>::out_arg_val _tao_p4 (p4);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_p1,
      &_tao_p2,
      &_tao_p4
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      4,
      "opu",
      3,
      TAO::TAO_CO_NONE | TAO::TAO_CO_THRU_POA_STRATEGY
      
    );

  _tao_call.invoke (0, 0);

  return _tao_retval.retn ();
}

// TAO_IDL - Generated from
// be/be_visitor_operation/operation_cs.cpp:91

::CORBA::Long
simple::TestInterf::attr1 (
  void)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  TAO::Arg_Traits< ::CORBA::Long>::ret_val _tao_retval;

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      1,
      "_get_attr1",
      10,
      TAO::TAO_CO_NONE | TAO::TAO_CO_THRU_POA_STRATEGY,
      TAO::TAO_TWOWAY_INVOCATION
      ,
      TAO::TAO_SYNCHRONOUS_INVOCATION,
      false
    );

  _tao_call.invoke (0, 0);

  return _tao_retval.retn ();
}

// TAO_IDL - Generated from
// be/be_visitor_operation/operation_cs.cpp:91

void
simple::TestInterf::attr1 (
  ::CORBA::Long attr1)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::CORBA::Long>::in_arg_val _tao_attr1 (attr1);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_attr1
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      2,
      "_set_attr1",
      10,
      TAO::TAO_CO_NONE | TAO::TAO_CO_THRU_POA_STRATEGY
      
    );

  _tao_call.invoke (0, 0);
}

simple::TestInterf::TestInterf (void)
{
}

simple::TestInterf::~TestInterf (void)
{
}

simple::TestInterf_ptr
simple::TestInterf::_narrow (
    ::CORBA::Object_ptr _tao_objref)
{
  return
    TAO::Narrow_Utils<TestInterf>::narrow (
        _tao_objref,
        "IDL:simple/TestInterf:1.0");
}

simple::TestInterf_ptr
simple::TestInterf::_unchecked_narrow (
    ::CORBA::Object_ptr _tao_objref)
{
  return
    TAO::Narrow_Utils<TestInterf>::unchecked_narrow (
        _tao_objref);
}

simple::TestInterf_ptr
simple::TestInterf::_nil (void)
{
  return 0;
}

simple::TestInterf_ptr
simple::TestInterf::_duplicate (TestInterf_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  return obj;
}

void
simple::TestInterf::_tao_release (TestInterf_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
simple::TestInterf::_is_a (const char *value)
{
  if (
      ACE_OS::strcmp (
          value,
          "IDL:simple/TestInterf:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Object:1.0"
        ) == 0
    )
    {
      return true; // success using local knowledge
    }
  else
    {
      return this->::CORBA::Object::_is_a (value);
    }
}

const char* simple::TestInterf::_interface_repository_id (void) const
{
  return "IDL:simple/TestInterf:1.0";
}

::CORBA::Boolean
simple::TestInterf::marshal (TAO_OutputCDR &cdr)
{
  return (cdr << this);
}

// TAO_IDL - Generated from
// be/be_visitor_sequence/sequence_cs.cpp:73

#if !defined (_SIMPLE_TESTUNION2SEQ_CS_)
#define _SIMPLE_TESTUNION2SEQ_CS_

simple::TestUnion2Seq::TestUnion2Seq (void)
{}

simple::TestUnion2Seq::TestUnion2Seq (
    ::CORBA::ULong max)
  : ::TAO::unbounded_value_sequence<
        TestUnion2
      > (max)
{}

simple::TestUnion2Seq::TestUnion2Seq (
    ::CORBA::ULong max,
    ::CORBA::ULong length,
    simple::TestUnion2 * buffer,
    ::CORBA::Boolean release
  )
  : ::TAO::unbounded_value_sequence<
        TestUnion2
      >
    (max, length, buffer, release)
{}

simple::TestUnion2Seq::TestUnion2Seq (
    const TestUnion2Seq &seq)
  : ::TAO::unbounded_value_sequence<
        TestUnion2
      > (seq)
{}

simple::TestUnion2Seq::~TestUnion2Seq (void)
{}

#endif /* end #if !defined */

// TAO_IDL - Generated from
// be/be_visitor_union/union_cs.cpp:79

simple::TestUnion3::TestUnion3 (void)
{
  ACE_OS::memset (&this->u_, 0, sizeof (this->u_));
  this->disc_ = simple::d;
}

simple::TestUnion3::TestUnion3 (const ::simple::TestUnion3 &u)
{
  this->disc_ = u.disc_;
  switch (this->disc_)
  {
    case simple::a:
    {
      // Make a deep copy.
      this->u_.sa_ = 
        simple::TestStructArray_dup (u.u_.sa_);
    }
    break;
    case simple::b:
    {
      if (u.u_.obj_ == 0)
        {
          this->u_.obj_ = 0;
        }
      else
        {
          typedef simple::TestInterf_var OBJECT_FIELD;
          ACE_NEW (
              this->u_.obj_,
              OBJECT_FIELD (
                  simple::TestInterf::_duplicate (
                      u.u_.obj_->in ()
                    )
                )
            );
        }
    }
    break;
    case simple::c:
    {
      if (u.u_.us_ == 0)
        {
          this->u_.us_ = 0;
        }
      else
        {
          ACE_NEW (
              this->u_.us_,
              simple::TestUnion2Seq (*u.u_.us_)
            );
        }
    }
    break;
    default:
    {
      this->u_.fp_ = u.u_.fp_;
    }
    break;
  }
}

simple::TestUnion3::~TestUnion3 (void)
{
  // Finalize.
  this->_reset ();
}

simple::TestUnion3 &
simple::TestUnion3::operator= (const ::simple::TestUnion3 &u)
{
  if (&u == this)
    {
      return *this;
    }
  
  this->_reset ();
  this->disc_ = u.disc_;

  switch (this->disc_)
  {
    case simple::a:
    {
      // Make a deep copy.
      this->u_.sa_ = 
        simple::TestStructArray_dup (u.u_.sa_);
    }
    break;
    case simple::b:
    {
      if (u.u_.obj_ == 0)
        {
          this->u_.obj_ = 0;
        }
      else
        {
          typedef simple::TestInterf_var OBJECT_FIELD;
          ACE_NEW_RETURN (
              this->u_.obj_,
              OBJECT_FIELD (
                  simple::TestInterf::_duplicate (
                      u.u_.obj_->in ()
                    )
                ),
              *this
            );
        }
    }
    break;
    case simple::c:
    {
      if (u.u_.us_ == 0)
        {
          this->u_.us_ = 0;
        }
      else
        {
          ACE_NEW_RETURN (
              this->u_.us_,
              simple::TestUnion2Seq (*u.u_.us_),
              *this
            );
        }
    }
    break;
    default:
    {
      this->u_.fp_ = u.u_.fp_;
    }
    break;
  }
  
  return *this;
}

/// Reset method to reset old values of a union.
void simple::TestUnion3::_reset (void)
{
  switch (this->disc_)
  {
    
    case simple::a:
      simple::TestStructArray_free (this->u_.sa_);
      this->u_.sa_ = 0;
      
    break;
    
    case simple::b:
      delete this->u_.obj_;
      this->u_.obj_ = 0;
      
    break;
    
    case simple::c:
      delete this->u_.us_;
      this->u_.us_ = 0;
      
    break;
    
    default:
      
    break;
    
  }
}

// TAO_IDL - Generated from
// be/be_visitor_interface/interface_cs.cpp:51

// Traits specializations for simple::TestInterf2.

simple::TestInterf2_ptr
TAO::Objref_Traits<simple::TestInterf2>::duplicate (
    simple::TestInterf2_ptr p)
{
  return simple::TestInterf2::_duplicate (p);
}

void
TAO::Objref_Traits<simple::TestInterf2>::release (
    simple::TestInterf2_ptr p)
{
  ::CORBA::release (p);
}

simple::TestInterf2_ptr
TAO::Objref_Traits<simple::TestInterf2>::nil (void)
{
  return simple::TestInterf2::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<simple::TestInterf2>::marshal (
    const simple::TestInterf2_ptr p,
    TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

// TAO_IDL - Generated from
// be/be_visitor_operation/operation_cs.cpp:91

::CORBA::Long
simple::TestInterf2::op2 (
  const ::simple::TestArrayTypedef p1,
  const ::simple::LongSeqSeq & p2)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  TAO::Arg_Traits< ::CORBA::Long>::ret_val _tao_retval;
  TAO::Arg_Traits< ::simple::TestArrayTypedef_tag>::in_arg_val _tao_p1 (p1);
  TAO::Arg_Traits< ::simple::LongSeqSeq>::in_arg_val _tao_p2 (p2);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_p1,
      &_tao_p2
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      3,
      "op2",
      3,
      TAO::TAO_CO_NONE | TAO::TAO_CO_THRU_POA_STRATEGY
      
    );

  _tao_call.invoke (0, 0);

  return _tao_retval.retn ();
}

simple::TestInterf2::TestInterf2 (void)
{
}

simple::TestInterf2::~TestInterf2 (void)
{
}

simple::TestInterf2_ptr
simple::TestInterf2::_narrow (
    ::CORBA::Object_ptr _tao_objref)
{
  return
    TAO::Narrow_Utils<TestInterf2>::narrow (
        _tao_objref,
        "IDL:simple/TestInterf2:1.0");
}

simple::TestInterf2_ptr
simple::TestInterf2::_unchecked_narrow (
    ::CORBA::Object_ptr _tao_objref)
{
  return
    TAO::Narrow_Utils<TestInterf2>::unchecked_narrow (
        _tao_objref);
}

simple::TestInterf2_ptr
simple::TestInterf2::_nil (void)
{
  return 0;
}

simple::TestInterf2_ptr
simple::TestInterf2::_duplicate (TestInterf2_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  return obj;
}

void
simple::TestInterf2::_tao_release (TestInterf2_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
simple::TestInterf2::_is_a (const char *value)
{
  if (
      ACE_OS::strcmp (
          value,
          "IDL:simple/TestInterf:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:simple/TestInterf2:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Object:1.0"
        ) == 0
    )
    {
      return true; // success using local knowledge
    }
  else
    {
      return this->::CORBA::Object::_is_a (value);
    }
}

const char* simple::TestInterf2::_interface_repository_id (void) const
{
  return "IDL:simple/TestInterf2:1.0";
}

::CORBA::Boolean
simple::TestInterf2::marshal (TAO_OutputCDR &cdr)
{
  return (cdr << this);
}

// TAO_IDL - Generated from
// be/be_visitor_interface/interface_cs.cpp:51

// Traits specializations for simple::TestInterf3.

simple::TestInterf3_ptr
TAO::Objref_Traits<simple::TestInterf3>::duplicate (
    simple::TestInterf3_ptr p)
{
  return simple::TestInterf3::_duplicate (p);
}

void
TAO::Objref_Traits<simple::TestInterf3>::release (
    simple::TestInterf3_ptr p)
{
  ::CORBA::release (p);
}

simple::TestInterf3_ptr
TAO::Objref_Traits<simple::TestInterf3>::nil (void)
{
  return simple::TestInterf3::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<simple::TestInterf3>::marshal (
    const simple::TestInterf3_ptr p,
    TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

// TAO_IDL - Generated from
// be/be_visitor_operation/operation_cs.cpp:91

void
simple::TestInterf3::op3 (
  const ::simple::TestNestedStruct & p1)
{
  if (!this->is_evaluated ())
    {
      ::CORBA::Object::tao_object_initialize (this);
    }
  
  TAO::Arg_Traits< void>::ret_val _tao_retval;
  TAO::Arg_Traits< ::simple::TestNestedStruct>::in_arg_val _tao_p1 (p1);

  TAO::Argument *_the_tao_operation_signature [] =
    {
      &_tao_retval,
      &_tao_p1
    };

  TAO::Invocation_Adapter _tao_call (
      this,
      _the_tao_operation_signature,
      2,
      "op3",
      3,
      TAO::TAO_CO_NONE | TAO::TAO_CO_THRU_POA_STRATEGY
      
    );

  _tao_call.invoke (0, 0);
}

simple::TestInterf3::TestInterf3 (void)
{
}

simple::TestInterf3::~TestInterf3 (void)
{
}

simple::TestInterf3_ptr
simple::TestInterf3::_narrow (
    ::CORBA::Object_ptr _tao_objref)
{
  return
    TAO::Narrow_Utils<TestInterf3>::narrow (
        _tao_objref,
        "IDL:simple/TestInterf3:1.0");
}

simple::TestInterf3_ptr
simple::TestInterf3::_unchecked_narrow (
    ::CORBA::Object_ptr _tao_objref)
{
  return
    TAO::Narrow_Utils<TestInterf3>::unchecked_narrow (
        _tao_objref);
}

simple::TestInterf3_ptr
simple::TestInterf3::_nil (void)
{
  return 0;
}

simple::TestInterf3_ptr
simple::TestInterf3::_duplicate (TestInterf3_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  return obj;
}

void
simple::TestInterf3::_tao_release (TestInterf3_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
simple::TestInterf3::_is_a (const char *value)
{
  if (
      ACE_OS::strcmp (
          value,
          "IDL:simple/TestInterf:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:simple/TestInterf2:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:simple/TestInterf3:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Object:1.0"
        ) == 0
    )
    {
      return true; // success using local knowledge
    }
  else
    {
      return this->::CORBA::Object::_is_a (value);
    }
}

const char* simple::TestInterf3::_interface_repository_id (void) const
{
  return "IDL:simple/TestInterf3:1.0";
}

::CORBA::Boolean
simple::TestInterf3::marshal (TAO_OutputCDR &cdr)
{
  return (cdr << this);
}

// TAO_IDL - Generated from
// be/be_visitor_interface/interface_cs.cpp:51

// Traits specializations for simple::TestLI.

simple::TestLI_ptr
TAO::Objref_Traits<simple::TestLI>::duplicate (
    simple::TestLI_ptr p)
{
  return simple::TestLI::_duplicate (p);
}

void
TAO::Objref_Traits<simple::TestLI>::release (
    simple::TestLI_ptr p)
{
  ::CORBA::release (p);
}

simple::TestLI_ptr
TAO::Objref_Traits<simple::TestLI>::nil (void)
{
  return simple::TestLI::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<simple::TestLI>::marshal (
    const simple::TestLI_ptr p,
    TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

simple::TestLI::TestLI (void)
{}

simple::TestLI::~TestLI (void)
{
}

simple::TestLI_ptr
simple::TestLI::_narrow (
    ::CORBA::Object_ptr _tao_objref)
{
  return TestLI::_duplicate (
      dynamic_cast<TestLI_ptr> (_tao_objref)
    );
}

simple::TestLI_ptr
simple::TestLI::_unchecked_narrow (
    ::CORBA::Object_ptr _tao_objref)
{
  return TestLI::_duplicate (
      dynamic_cast<TestLI_ptr> (_tao_objref)
    );
}

simple::TestLI_ptr
simple::TestLI::_nil (void)
{
  return 0;
}

simple::TestLI_ptr
simple::TestLI::_duplicate (TestLI_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  return obj;
}

void
simple::TestLI::_tao_release (TestLI_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
simple::TestLI::_is_a (const char *value)
{
  if (
      ACE_OS::strcmp (
          value,
          "IDL:simple/TestLI:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/LocalObject:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Object:1.0"
        ) == 0
    )
    {
      return true; // success using local knowledge
    }
  else
    {
      return false;
    }
}

const char* simple::TestLI::_interface_repository_id (void) const
{
  return "IDL:simple/TestLI:1.0";
}

::CORBA::Boolean
simple::TestLI::marshal (TAO_OutputCDR & /* cdr */)
{
  return false;
}

// TAO_IDL - Generated from
// be/be_visitor_interface/interface_cs.cpp:51

// Traits specializations for simple::Local2.

simple::Local2_ptr
TAO::Objref_Traits<simple::Local2>::duplicate (
    simple::Local2_ptr p)
{
  return simple::Local2::_duplicate (p);
}

void
TAO::Objref_Traits<simple::Local2>::release (
    simple::Local2_ptr p)
{
  ::CORBA::release (p);
}

simple::Local2_ptr
TAO::Objref_Traits<simple::Local2>::nil (void)
{
  return simple::Local2::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<simple::Local2>::marshal (
    const simple::Local2_ptr p,
    TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

simple::Local2::Local2 (void)
{}

simple::Local2::~Local2 (void)
{
}

simple::Local2_ptr
simple::Local2::_narrow (
    ::CORBA::Object_ptr _tao_objref)
{
  return Local2::_duplicate (
      dynamic_cast<Local2_ptr> (_tao_objref)
    );
}

simple::Local2_ptr
simple::Local2::_unchecked_narrow (
    ::CORBA::Object_ptr _tao_objref)
{
  return Local2::_duplicate (
      dynamic_cast<Local2_ptr> (_tao_objref)
    );
}

simple::Local2_ptr
simple::Local2::_nil (void)
{
  return 0;
}

simple::Local2_ptr
simple::Local2::_duplicate (Local2_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  return obj;
}

void
simple::Local2::_tao_release (Local2_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
simple::Local2::_is_a (const char *value)
{
  if (
      ACE_OS::strcmp (
          value,
          "IDL:simple/TestLI:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:simple/Local2:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/LocalObject:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Object:1.0"
        ) == 0
    )
    {
      return true; // success using local knowledge
    }
  else
    {
      return false;
    }
}

const char* simple::Local2::_interface_repository_id (void) const
{
  return "IDL:simple/Local2:1.0";
}

::CORBA::Boolean
simple::Local2::marshal (TAO_OutputCDR & /* cdr */)
{
  return false;
}

// TAO_IDL - Generated from
// be/be_visitor_sequence/sequence_cs.cpp:73

#if !defined (_SIMPLE_LOCAL2SEQ_CS_)
#define _SIMPLE_LOCAL2SEQ_CS_

simple::Local2Seq::Local2Seq (void)
{}

simple::Local2Seq::Local2Seq (
    ::CORBA::ULong max)
  : ::TAO::unbounded_object_reference_sequence<
        Local2,
        Local2_var
      > (max)
{}

simple::Local2Seq::Local2Seq (
    ::CORBA::ULong max,
    ::CORBA::ULong length,
    simple::Local2_ptr * buffer,
    ::CORBA::Boolean release
  )
  : ::TAO::unbounded_object_reference_sequence<
        Local2,
        Local2_var
      >
    (max, length, buffer, release)
{}

simple::Local2Seq::Local2Seq (
    const Local2Seq &seq)
  : ::TAO::unbounded_object_reference_sequence<
        Local2,
        Local2_var
      > (seq)
{}

simple::Local2Seq::~Local2Seq (void)
{}

#endif /* end #if !defined */

// TAO_IDL - Generated from
// be/be_visitor_interface/interface_cs.cpp:51

// Traits specializations for simple::Local3.

simple::Local3_ptr
TAO::Objref_Traits<simple::Local3>::duplicate (
    simple::Local3_ptr p)
{
  return simple::Local3::_duplicate (p);
}

void
TAO::Objref_Traits<simple::Local3>::release (
    simple::Local3_ptr p)
{
  ::CORBA::release (p);
}

simple::Local3_ptr
TAO::Objref_Traits<simple::Local3>::nil (void)
{
  return simple::Local3::_nil ();
}

::CORBA::Boolean
TAO::Objref_Traits<simple::Local3>::marshal (
    const simple::Local3_ptr p,
    TAO_OutputCDR & cdr)
{
  return ::CORBA::Object::marshal (p, cdr);
}

simple::Local3::Local3 (void)
{}

simple::Local3::~Local3 (void)
{
}

simple::Local3_ptr
simple::Local3::_narrow (
    ::CORBA::Object_ptr _tao_objref)
{
  return Local3::_duplicate (
      dynamic_cast<Local3_ptr> (_tao_objref)
    );
}

simple::Local3_ptr
simple::Local3::_unchecked_narrow (
    ::CORBA::Object_ptr _tao_objref)
{
  return Local3::_duplicate (
      dynamic_cast<Local3_ptr> (_tao_objref)
    );
}

simple::Local3_ptr
simple::Local3::_nil (void)
{
  return 0;
}

simple::Local3_ptr
simple::Local3::_duplicate (Local3_ptr obj)
{
  if (! ::CORBA::is_nil (obj))
    {
      obj->_add_ref ();
    }
  return obj;
}

void
simple::Local3::_tao_release (Local3_ptr obj)
{
  ::CORBA::release (obj);
}

::CORBA::Boolean
simple::Local3::_is_a (const char *value)
{
  if (
      ACE_OS::strcmp (
          value,
          "IDL:simple/TestLI:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:simple/Local2:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:simple/Local3:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/LocalObject:1.0"
        ) == 0 ||
      ACE_OS::strcmp (
          value,
          "IDL:omg.org/CORBA/Object:1.0"
        ) == 0
    )
    {
      return true; // success using local knowledge
    }
  else
    {
      return false;
    }
}

const char* simple::Local3::_interface_repository_id (void) const
{
  return "IDL:simple/Local3:1.0";
}

::CORBA::Boolean
simple::Local3::marshal (TAO_OutputCDR & /* cdr */)
{
  return false;
}

// TAO_IDL - Generated from
// be/be_visitor_sequence/cdr_op_cs.cpp:96
#if !defined _TAO_CDR_OP_simple_TestSeqTypedef_CPP_
#define _TAO_CDR_OP_simple_TestSeqTypedef_CPP_

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const simple::TestSeqTypedef &_tao_sequence)
{
  return TAO::marshal_sequence(strm, _tao_sequence);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    simple::TestSeqTypedef &_tao_sequence)
{
  return TAO::demarshal_sequence(strm, _tao_sequence);
}


TAO_END_VERSIONED_NAMESPACE_DECL

#endif /* _TAO_CDR_OP_simple_TestSeqTypedef_CPP_ */

// TAO_IDL - Generated from
// be/be_visitor_sequence/cdr_op_cs.cpp:96
#if !defined _TAO_CDR_OP_simple_SeqOfTypedefedLong_CPP_
#define _TAO_CDR_OP_simple_SeqOfTypedefedLong_CPP_

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const simple::SeqOfTypedefedLong &_tao_sequence)
{
  return TAO::marshal_sequence(strm, _tao_sequence);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    simple::SeqOfTypedefedLong &_tao_sequence)
{
  return TAO::demarshal_sequence(strm, _tao_sequence);
}


TAO_END_VERSIONED_NAMESPACE_DECL

#endif /* _TAO_CDR_OP_simple_SeqOfTypedefedLong_CPP_ */

// TAO_IDL - Generated from
// be/be_visitor_sequence/cdr_op_cs.cpp:96
#if !defined _TAO_CDR_OP_simple_StringSeq_CPP_
#define _TAO_CDR_OP_simple_StringSeq_CPP_

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const simple::StringSeq &_tao_sequence)
{
  return TAO::marshal_sequence(strm, _tao_sequence);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    simple::StringSeq &_tao_sequence)
{
  return TAO::demarshal_sequence(strm, _tao_sequence);
}


TAO_END_VERSIONED_NAMESPACE_DECL

#endif /* _TAO_CDR_OP_simple_StringSeq_CPP_ */

// TAO_IDL - Generated from
// be/be_visitor_array/cdr_op_cs.cpp:166


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const simple::TestArrayTypedef_forany &_tao_array)
{
  return
    strm.write_long_array (
        reinterpret_cast <const ACE_CDR::Long *> (_tao_array.in ()),
        4);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    simple::TestArrayTypedef_forany &_tao_array)
{
  return
    strm.read_long_array (
        reinterpret_cast <ACE_CDR::Long *> (_tao_array.out ()),
        4);
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// be/be_visitor_array/cdr_op_cs.cpp:166


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const simple::TestStringArray_forany &_tao_array)
{
  CORBA::Boolean _tao_marshal_flag = true;
  
  for ( ::CORBA::ULong i0 = 0; i0 < 4 && _tao_marshal_flag; ++i0)
    {
      _tao_marshal_flag = (strm << _tao_array [i0].in ());
    }

  return _tao_marshal_flag;
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    simple::TestStringArray_forany &_tao_array)
{
  CORBA::Boolean _tao_marshal_flag = true;
  
  for ( ::CORBA::ULong i0 = 0; i0 < 4 && _tao_marshal_flag; ++i0)
    {
      _tao_marshal_flag = (strm >> _tao_array [i0].out ());
    }

  return _tao_marshal_flag;
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// be/be_visitor_sequence/cdr_op_cs.cpp:96
#if !defined _TAO_CDR_OP_simple_StringSeqSeq_CPP_
#define _TAO_CDR_OP_simple_StringSeqSeq_CPP_

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const simple::StringSeqSeq &_tao_sequence)
{
  return TAO::marshal_sequence(strm, _tao_sequence);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    simple::StringSeqSeq &_tao_sequence)
{
  return TAO::demarshal_sequence(strm, _tao_sequence);
}


TAO_END_VERSIONED_NAMESPACE_DECL

#endif /* _TAO_CDR_OP_simple_StringSeqSeq_CPP_ */

// TAO_IDL - Generated from
// be/be_visitor_sequence/cdr_op_cs.cpp:96
#if !defined _TAO_CDR_OP_simple_StringSeqSeqSeq_CPP_
#define _TAO_CDR_OP_simple_StringSeqSeqSeq_CPP_

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const simple::StringSeqSeqSeq &_tao_sequence)
{
  return TAO::marshal_sequence(strm, _tao_sequence);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    simple::StringSeqSeqSeq &_tao_sequence)
{
  return TAO::demarshal_sequence(strm, _tao_sequence);
}


TAO_END_VERSIONED_NAMESPACE_DECL

#endif /* _TAO_CDR_OP_simple_StringSeqSeqSeq_CPP_ */

// TAO_IDL - Generated from
// be/be_visitor_sequence/cdr_op_cs.cpp:96
#if !defined _TAO_CDR_OP_simple_LongSeqSeq_CPP_
#define _TAO_CDR_OP_simple_LongSeqSeq_CPP_

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const simple::LongSeqSeq &_tao_sequence)
{
  return TAO::marshal_sequence(strm, _tao_sequence);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    simple::LongSeqSeq &_tao_sequence)
{
  return TAO::demarshal_sequence(strm, _tao_sequence);
}


TAO_END_VERSIONED_NAMESPACE_DECL

#endif /* _TAO_CDR_OP_simple_LongSeqSeq_CPP_ */

// TAO_IDL - Generated from
// be/be_visitor_sequence/cdr_op_cs.cpp:96
#if !defined _TAO_CDR_OP_simple_LongSeqSeqSeq_CPP_
#define _TAO_CDR_OP_simple_LongSeqSeqSeq_CPP_

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const simple::LongSeqSeqSeq &_tao_sequence)
{
  return TAO::marshal_sequence(strm, _tao_sequence);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    simple::LongSeqSeqSeq &_tao_sequence)
{
  return TAO::demarshal_sequence(strm, _tao_sequence);
}


TAO_END_VERSIONED_NAMESPACE_DECL

#endif /* _TAO_CDR_OP_simple_LongSeqSeqSeq_CPP_ */

// TAO_IDL - Generated from
// be/be_visitor_structure/cdr_op_cs.cpp:52

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const simple::TestStruct &_tao_aggregate)
{
  return
    (strm << _tao_aggregate.m1) &&
    (strm << _tao_aggregate.m2) &&
    (strm << _tao_aggregate.seq1) &&
    (strm << _tao_aggregate.seq2) &&
    (strm << _tao_aggregate.st.in ());
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    simple::TestStruct &_tao_aggregate)
{
  return
    (strm >> _tao_aggregate.m1) &&
    (strm >> _tao_aggregate.m2) &&
    (strm >> _tao_aggregate.seq1) &&
    (strm >> _tao_aggregate.seq2) &&
    (strm >> _tao_aggregate.st.out ());
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// be/be_visitor_sequence/cdr_op_cs.cpp:96
#if !defined _TAO_CDR_OP_simple_TestStructSequence_CPP_
#define _TAO_CDR_OP_simple_TestStructSequence_CPP_

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const simple::TestStructSequence &_tao_sequence)
{
  return TAO::marshal_sequence(strm, _tao_sequence);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    simple::TestStructSequence &_tao_sequence)
{
  return TAO::demarshal_sequence(strm, _tao_sequence);
}


TAO_END_VERSIONED_NAMESPACE_DECL

#endif /* _TAO_CDR_OP_simple_TestStructSequence_CPP_ */

// TAO_IDL - Generated from
// be/be_visitor_array/cdr_op_cs.cpp:166


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const simple::TestStructArray_forany &_tao_array)
{
  CORBA::Boolean _tao_marshal_flag = true;
  
  for ( ::CORBA::ULong i0 = 0; i0 < 4 && _tao_marshal_flag; ++i0)
    {
      _tao_marshal_flag = (strm << _tao_array [i0]);
    }

  return _tao_marshal_flag;
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    simple::TestStructArray_forany &_tao_array)
{
  CORBA::Boolean _tao_marshal_flag = true;
  
  for ( ::CORBA::ULong i0 = 0; i0 < 4 && _tao_marshal_flag; ++i0)
    {
      _tao_marshal_flag = (strm >> _tao_array [i0]);
    }

  return _tao_marshal_flag;
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// be/be_visitor_structure/cdr_op_cs.cpp:52

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const simple::TestNestedStruct &_tao_aggregate)
{
  simple::TestArrayTypedef_forany _tao_aggregate_arr
      #if defined __IBMCPP__ && __IBMCPP__ <= 800
      ((simple::TestArrayTypedef_slice*) (
      #else
      (const_cast<
          simple::TestArrayTypedef_slice*> (
      #endif
          _tao_aggregate.arr
        )
    );
  return
    (strm << _tao_aggregate.m) &&
    (strm << _tao_aggregate.str.in ()) &&
    (strm << _tao_aggregate_arr) &&
    (strm << _tao_aggregate.sss) &&
    (strm << _tao_aggregate.ssss) &&
    (strm << _tao_aggregate.lss) &&
    (strm << _tao_aggregate.lsss);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    simple::TestNestedStruct &_tao_aggregate)
{
  simple::TestArrayTypedef_forany _tao_aggregate_arr
      #if defined __IBMCPP__ && __IBMCPP__ <= 800
      ((simple::TestArrayTypedef_slice*) (
      #else
      (const_cast<
          simple::TestArrayTypedef_slice*> (
      #endif
          _tao_aggregate.arr
        )
    );
  return
    (strm >> _tao_aggregate.m) &&
    (strm >> _tao_aggregate.str.out ()) &&
    (strm >> _tao_aggregate_arr) &&
    (strm >> _tao_aggregate.sss) &&
    (strm >> _tao_aggregate.ssss) &&
    (strm >> _tao_aggregate.lss) &&
    (strm >> _tao_aggregate.lsss);
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// be/be_visitor_enum/cdr_op_cs.cpp:37


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (TAO_OutputCDR &strm, simple::TestEnum _tao_enumerator)
{
  return strm << static_cast< ::CORBA::ULong> (_tao_enumerator);
}

::CORBA::Boolean operator>> (TAO_InputCDR &strm, simple::TestEnum & _tao_enumerator)
{
  ::CORBA::ULong _tao_temp = 0;
  ::CORBA::Boolean const _tao_success = strm >> _tao_temp;
  
  if (_tao_success)
    {
      _tao_enumerator = static_cast<simple::TestEnum> (_tao_temp);
    }
  
  return _tao_success;
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// be/be_visitor_union/cdr_op_cs.cpp:77


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const simple::TestUnion1 &_tao_union
  )
{
  if ( !(strm << _tao_union._d ()) )
    {
      return false;
    }
  
  ::CORBA::Boolean result = true;

  switch (_tao_union._d ())
  {
    case simple::a:
      {
        result = strm << ::ACE_OutputCDR::from_octet (_tao_union.o ());
      }
      break;
    case simple::b:
      {
        result = strm << _tao_union.s ();
      }
      break;
    case simple::c:
      {
        result = strm << _tao_union.l ();
      }
      break;
    case simple::d:
      {
        result = strm << ::ACE_OutputCDR::from_boolean (_tao_union.n ());
      }
      break;
    case simple::e:
      {
        result = strm << _tao_union.u ();
      }
      break;
    default:
      break;
  }

  return result;
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    simple::TestUnion1 &_tao_union
  )
{
  simple::TestEnum _tao_discriminant;
  if ( !(strm >> _tao_discriminant) )
    {
      return false;
    }
  
  ::CORBA::Boolean result = true;

  switch (_tao_discriminant)
  {
    case simple::a:
      {
        ::CORBA::Octet _tao_union_tmp;
        ::ACE_InputCDR::to_octet _tao_union_helper (_tao_union_tmp);
        result = strm >> _tao_union_helper;

        if (result)
          {
            _tao_union.o (_tao_union_tmp);
            _tao_union._d (_tao_discriminant);
          }
      }
      break;
    case simple::b:
      {
        CORBA::Short _tao_union_tmp;
        result = strm >> _tao_union_tmp;

        if (result)
          {
            _tao_union.s (_tao_union_tmp);
            _tao_union._d (_tao_discriminant);
          }
      }
      break;
    case simple::c:
      {
        CORBA::Long _tao_union_tmp;
        result = strm >> _tao_union_tmp;

        if (result)
          {
            _tao_union.l (_tao_union_tmp);
            _tao_union._d (_tao_discriminant);
          }
      }
      break;
    case simple::d:
      {
        ::CORBA::Boolean _tao_union_tmp;
        ::ACE_InputCDR::to_boolean _tao_union_helper (_tao_union_tmp);
        result = strm >> _tao_union_helper;

        if (result)
          {
            _tao_union.n (_tao_union_tmp);
            _tao_union._d (_tao_discriminant);
          }
      }
      break;
    case simple::e:
      {
        CORBA::Double _tao_union_tmp;
        result = strm >> _tao_union_tmp;

        if (result)
          {
            _tao_union.u (_tao_union_tmp);
            _tao_union._d (_tao_discriminant);
          }
      }
      break;
    default:
      _tao_union._default ();
      // For maximum interop compatability, force the same value as transmitted
      _tao_union._d (_tao_discriminant);
      break;
  }

  return result;
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// be/be_visitor_union/cdr_op_cs.cpp:77


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const simple::TestUnion2 &_tao_union
  )
{
  if ( !(strm << _tao_union._d ()) )
    {
      return false;
    }
  
  ::CORBA::Boolean result = true;

  switch (_tao_union._d ())
  {
    case 0:
      {
        result = strm << _tao_union.s ();
      }
      break;
    case 1:
      {
        result = strm << _tao_union.t ();
      }
      break;
    case 2:
    case 3:
      {
        result = strm << _tao_union.q ();
      }
      break;
    case 4:
      {
        result = strm << _tao_union.d ();
      }
      break;
    default:
      {
        result = strm << _tao_union.e ();
      }
      break;
  }

  return result;
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    simple::TestUnion2 &_tao_union
  )
{
  CORBA::Short _tao_discriminant;
  if ( !(strm >> _tao_discriminant) )
    {
      return false;
    }
  
  ::CORBA::Boolean result = true;

  switch (_tao_discriminant)
  {
    case 0:
      {
        ::CORBA::String_var _tao_union_tmp;
        result = strm >> _tao_union_tmp.out ();

        if (result)
          {
            _tao_union.s (_tao_union_tmp);
            _tao_union._d (_tao_discriminant);
          }
      }
      break;
    case 1:
      {
        simple::TestStruct _tao_union_tmp;
        result = strm >> _tao_union_tmp;

        if (result)
          {
            _tao_union.t (_tao_union_tmp);
            _tao_union._d (_tao_discriminant);
          }
      }
      break;
    case 2:
    case 3:
      {
        simple::TestSeqTypedef _tao_union_tmp;
        result = strm >> _tao_union_tmp;

        if (result)
          {
            _tao_union.q (_tao_union_tmp);
            _tao_union._d (_tao_discriminant);
          }
      }
      break;
    case 4:
      {
        ::CORBA::String_var _tao_union_tmp;
        result = strm >> _tao_union_tmp.out ();

        if (result)
          {
            _tao_union.d (_tao_union_tmp);
            _tao_union._d (_tao_discriminant);
          }
      }
      break;
    default:
      {
        simple::TestEnum _tao_union_tmp =
          static_cast<simple::TestEnum> (0UL);
        result = strm >> _tao_union_tmp;

        if (result)
          {
            _tao_union.e (_tao_union_tmp);
            _tao_union._d (_tao_discriminant);
          }
      }
      break;
  }

  return result;
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// be/be_visitor_union/cdr_op_cs.cpp:77


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const simple::TestUnion4 &_tao_union
  )
{
  ::ACE_OutputCDR::from_boolean tmp (_tao_union._d ());
  if ( !(strm << tmp) )
    {
      return false;
    }
  
  ::CORBA::Boolean result = true;

  if (_tao_union._d ())
    {
      result = strm << ::ACE_OutputCDR::from_char (_tao_union.c ());
    }
  
  return result;
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    simple::TestUnion4 &_tao_union
  )
{
  CORBA::Boolean _tao_discriminant;
  ::ACE_InputCDR::to_boolean tmp (_tao_discriminant);
  if ( !(strm >> tmp) )
    {
      return false;
    }
  
  ::CORBA::Boolean result = true;

  _tao_union._default ();
  _tao_union._d (_tao_discriminant);
  if (_tao_discriminant)
    {
      ::CORBA::Char _tao_union_tmp;
      ::ACE_InputCDR::to_char _tao_union_helper (_tao_union_tmp);
      result = strm >> _tao_union_helper;

      if (result)
        {
          _tao_union.c (_tao_union_tmp);
          _tao_union._d (_tao_discriminant);
        }
    }
  
  return result;
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// be/be_visitor_sequence/cdr_op_cs.cpp:96
#if !defined _TAO_CDR_OP_simple_EnumSeq_CPP_
#define _TAO_CDR_OP_simple_EnumSeq_CPP_

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const simple::EnumSeq &_tao_sequence)
{
  return TAO::marshal_sequence(strm, _tao_sequence);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    simple::EnumSeq &_tao_sequence)
{
  return TAO::demarshal_sequence(strm, _tao_sequence);
}


TAO_END_VERSIONED_NAMESPACE_DECL

#endif /* _TAO_CDR_OP_simple_EnumSeq_CPP_ */

// TAO_IDL - Generated from
// be/be_visitor_array/cdr_op_cs.cpp:166


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const simple::EnumArray_forany &_tao_array)
{
  CORBA::Boolean _tao_marshal_flag = true;
  
  for ( ::CORBA::ULong i0 = 0; i0 < 4 && _tao_marshal_flag; ++i0)
    {
      _tao_marshal_flag = (strm << _tao_array [i0]);
    }

  return _tao_marshal_flag;
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    simple::EnumArray_forany &_tao_array)
{
  CORBA::Boolean _tao_marshal_flag = true;
  
  for ( ::CORBA::ULong i0 = 0; i0 < 4 && _tao_marshal_flag; ++i0)
    {
      _tao_marshal_flag = (strm >> _tao_array [i0]);
    }

  return _tao_marshal_flag;
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// be/be_visitor_structure/cdr_op_cs.cpp:52

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const simple::TestStructWithEnum &_tao_aggregate)
{
  return
    (strm << _tao_aggregate.count) &&
    (strm << _tao_aggregate.which) &&
    (strm << _tao_aggregate.lotsOfEm) &&
    (strm << _tao_aggregate.fixedUnion) &&
    (strm << _tao_aggregate.variableUnion);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    simple::TestStructWithEnum &_tao_aggregate)
{
  return
    (strm >> _tao_aggregate.count) &&
    (strm >> _tao_aggregate.which) &&
    (strm >> _tao_aggregate.lotsOfEm) &&
    (strm >> _tao_aggregate.fixedUnion) &&
    (strm >> _tao_aggregate.variableUnion);
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// be/be_visitor_interface/cdr_op_cs.cpp:54

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const simple::TestInterf_ptr _tao_objref)
{
  ::CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    simple::TestInterf_ptr &_tao_objref)
{
  ::CORBA::Object_var obj;

  if (!(strm >> obj.inout ()))
    {
      return false;
    }
  
  typedef ::simple::TestInterf RHS_SCOPED_NAME;

  // Narrow to the right type.
  _tao_objref =
    TAO::Narrow_Utils<RHS_SCOPED_NAME>::unchecked_narrow (obj.in ());
    
  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// be/be_visitor_sequence/cdr_op_cs.cpp:96
#if !defined _TAO_CDR_OP_simple_TestUnion2Seq_CPP_
#define _TAO_CDR_OP_simple_TestUnion2Seq_CPP_

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const simple::TestUnion2Seq &_tao_sequence)
{
  return TAO::marshal_sequence(strm, _tao_sequence);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    simple::TestUnion2Seq &_tao_sequence)
{
  return TAO::demarshal_sequence(strm, _tao_sequence);
}


TAO_END_VERSIONED_NAMESPACE_DECL

#endif /* _TAO_CDR_OP_simple_TestUnion2Seq_CPP_ */

// TAO_IDL - Generated from
// be/be_visitor_union/cdr_op_cs.cpp:77


TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const simple::TestUnion3 &_tao_union
  )
{
  if ( !(strm << _tao_union._d ()) )
    {
      return false;
    }
  
  ::CORBA::Boolean result = true;

  switch (_tao_union._d ())
  {
    case simple::a:
      {
        simple::TestStructArray_forany _tao_union_tmp (
            _tao_union.sa ()
          );
        result = strm << _tao_union_tmp;
      }
      break;
    case simple::b:
      {
        result =
          TAO::Objref_Traits<simple::TestInterf>::marshal (
              _tao_union.obj (),
              strm
            );
      }
      break;
    case simple::c:
      {
        result = strm << _tao_union.us ();
      }
      break;
    default:
      {
        result = strm << _tao_union.fp ();
      }
      break;
  }

  return result;
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    simple::TestUnion3 &_tao_union
  )
{
  simple::TestEnum _tao_discriminant;
  if ( !(strm >> _tao_discriminant) )
    {
      return false;
    }
  
  ::CORBA::Boolean result = true;

  switch (_tao_discriminant)
  {
    case simple::a:
      {
        simple::TestStructArray _tao_union_tmp;
        simple::TestStructArray_forany _tao_union_helper (
            _tao_union_tmp
          );
        result = strm >> _tao_union_helper;

        if (result)
          {
            _tao_union.sa (_tao_union_tmp);
            _tao_union._d (_tao_discriminant);
          }
      }
      break;
    case simple::b:
      {
        simple::TestInterf_var _tao_union_tmp;
        result = strm >> _tao_union_tmp.inout ();

        if (result)
          {
            _tao_union.obj (_tao_union_tmp.in ());
            _tao_union._d (_tao_discriminant);
          }
      }
      break;
    case simple::c:
      {
        simple::TestUnion2Seq _tao_union_tmp;
        result = strm >> _tao_union_tmp;

        if (result)
          {
            _tao_union.us (_tao_union_tmp);
            _tao_union._d (_tao_discriminant);
          }
      }
      break;
    default:
      {
        CORBA::Double _tao_union_tmp;
        result = strm >> _tao_union_tmp;

        if (result)
          {
            _tao_union.fp (_tao_union_tmp);
            _tao_union._d (_tao_discriminant);
          }
      }
      break;
  }

  return result;
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// be/be_visitor_interface/cdr_op_cs.cpp:54

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const simple::TestInterf2_ptr _tao_objref)
{
  ::CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    simple::TestInterf2_ptr &_tao_objref)
{
  ::CORBA::Object_var obj;

  if (!(strm >> obj.inout ()))
    {
      return false;
    }
  
  typedef ::simple::TestInterf2 RHS_SCOPED_NAME;

  // Narrow to the right type.
  _tao_objref =
    TAO::Narrow_Utils<RHS_SCOPED_NAME>::unchecked_narrow (obj.in ());
    
  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL



// TAO_IDL - Generated from
// be/be_visitor_interface/cdr_op_cs.cpp:54

TAO_BEGIN_VERSIONED_NAMESPACE_DECL

::CORBA::Boolean operator<< (
    TAO_OutputCDR &strm,
    const simple::TestInterf3_ptr _tao_objref)
{
  ::CORBA::Object_ptr _tao_corba_obj = _tao_objref;
  return (strm << _tao_corba_obj);
}

::CORBA::Boolean operator>> (
    TAO_InputCDR &strm,
    simple::TestInterf3_ptr &_tao_objref)
{
  ::CORBA::Object_var obj;

  if (!(strm >> obj.inout ()))
    {
      return false;
    }
  
  typedef ::simple::TestInterf3 RHS_SCOPED_NAME;

  // Narrow to the right type.
  _tao_objref =
    TAO::Narrow_Utils<RHS_SCOPED_NAME>::unchecked_narrow (obj.in ());
    
  return true;
}

TAO_END_VERSIONED_NAMESPACE_DECL



